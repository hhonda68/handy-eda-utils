#
# FDFL (Fixed-point dataflow language) to Verilog converter
#

# Copyright (c) 2008 the handy-eda-utils developer(s).
# Distributed under the MIT License.
# (See accompanying file COPYING or copy at
#  http://www.opensource.org/licenses/mit-license.php.)

# Last modified on February 2008.

固定小数点演算データフロー回路の簡潔記述言語 FDFL

[A] 概要
  [A.1] 組み合わせロジック記述例
  [A.2] パイプラインロジック記述例
  [A.3] 階層設計記述例
[B] FDFL 構文
  [B.1] プリプロセッサ
    [B.1.1] コメント削除
    [B.1.2] 空行削除
    [B.1.3] ループ行展開
    [B.1.4] フィールド分解
    [B.1.5] レンジ付きフィールド展開
  [B.2] モジュール宣言／定義
  [B.3] 信号の型
  [B.4] 入出力信号や中間信号の宣言／定義
  [B.5] 式
  [B.6] インスタンス生成
  [B.7] 代入
  [B.8] パラメータ付きモジュール
    [B.8.1] パラメータ付きモジュールの定義と利用
    [B.8.2] パラメータ付きモジュールの宣言と利用
  [B.9] ビルトインモジュール
    [B.9.1] 演算子を実装するためのモジュール
    [B.9.2] 宣言無しでインスタンス生成できるモジュール
[C] ToDo
  [C.1] レジスタ初期値指定
  [C.2] 入出力一貫性チェック

========
[A] 概要
========

FDFL (Fixed-point Data-Flow Language) は、固定小数点演算データフローの
回路構造を簡潔に記述するための専用言語です。FDFL で記述した回路構造は、
コンバータを使って Verilog コードに自動変換することができるので、LSI 
設計の生産性が大幅に向上します。

FDFL がサポートする回路構造は以下の通りです。

  ・純粋組み合わせロジック
  ・単一クロックの完全同期式パイプライン演算フロー

FDFL は、データパスの設計に最適ですが、構造記述レベルでよければ制御パ
スも記述できます。

------------------------------
[A.1] 組み合わせロジック記述例
------------------------------

たとえば、次のような浮動小数点 C コードをがあったとします。

    double innerproduct(double a0, double a1, double b0, double b1) {
      return a0 * b0 + a1 * b1;
    }

これを固定小数点化して、次のようにビット数が決まったとします。

    int innerproduct(uint a0, uint a1, int b0, int b1) {
      int t0, t1, ret;
      //  a0,a1 : unsigned, total 12bit, fraction 8bit
      //  b0,b1 : signed,   total 14bit, fraction 7bit
      //  t0,t1 : signed,   total 15bit, fraction 4bit
      //  ret   : signed,   total 15bit, fraction 3bit
      t0 = fix_mul(a0, U,12,8, b0, S,14,7, S,15,4);
      t1 = fix_mul(a1, U,12,8, a1, S,14,7, S,15,4);
      ret = fix_add(t0, S,15,4, t1, S,15,4, S,15,3);
      return ret;
    }

この回路を、FDFL では次のように書くものとします。

    module innerproduct
    i u 12 8 a0 a1
    i s 14 7 b0 b1
    w s 15 4 t0 = a0 * b0
    w s 15 4 t1 = a1 * b1
    o s 15 3 ret = t0 + t1
    endmodule

# FDFL では、ビット数は総ビット数と小数部ビット数のペアで表します。

# =,*,+ 記号の前後に必ずスペースを入れる必要があります。

この FDFL コードをコンバータで Verilog コードに自動変換すると、
次のようになります。

    module innerproduct(a0,a1,b0,b1,ret);
      input  [11:0] a0;                     // U[4,8]
      input  [11:0] a1;                     // U[4,8]
      input  [13:0] b0;                     // S[7,7]
      input  [13:0] b1;                     // S[7,7]
      output [14:0] ret;                    // S[12,3]
      wire   [14:0] t0;                     // S[11,4]
      wire   [14:0] t1;                     // S[11,4]
      fix_mulus #(4,8,7,7,11,4) mul0(a0, b0, t0);
      fix_mulus #(4,8,7,7,11,4) mul1(a1, b1, t1);
      fix_addss #(11,4,11,4,12,3) add0(t0, t1, ret);
    endmodule

# Verilog コードのコメントでは、ビット数は整数部ビット数の小数部ビット
# 数のペアで表されます。

# fix_addss や fix_mulus の Verilog コードは、別途手作業で作るものとし
# ます。

--------------------------------
[A.2] パイプラインロジック記述例
--------------------------------

[A.1] 節の回路を、「乗算器の直後と関数出力値の 2 個所に FF を追加して
パイプライン化」する場合、FDFL としては以下のように書くものとします。

    module innerproduct_pipe
    i u 12 8 a0 a1
    i s 14 7 b0 b1
    r s 15 4 t0 = a0 * b0
    r s 15 4 t1 = a1 * b1
    q s 15 3 ret = t0 + t1
    endmodule

# "r" は internal register を表し、"q" は "registered output" を
# 表します。

この FDFL コードをコンバータで Verilog コードに自動変換すると、
次のようになります。

    module innerproduct_pipe(clk,a0,a1,b0,b1,ret);
      input         clk;
      input  [11:0] a0;                     // U[4,8]
      input  [11:0] a1;                     // U[4,8]
      input  [13:0] b0;                     // S[7,7]
      input  [13:0] b1;                     // S[7,7]
      output [14:0] ret;                    // S[12,3]
      reg    [14:0] ret;                    // S[12,3]
      wire   [14:0] ret_next_;              // S[12,3]
      reg    [14:0] t0;                     // S[11,4]
      wire   [14:0] t0_next_;               // S[11,4]
      reg    [14:0] t1;                     // S[11,4]
      wire   [14:0] t1_next_;               // S[11,4]
      fix_mulus #(4,8,7,7,11,4) mul0(a0, b0, t0_next_);
      fix_mulus #(4,8,7,7,11,4) mul1(a1, b1, t1_next_);
      fix_addss #(11,4,11,4,12,3) add0(t0, t1, ret_next_);
      always @(posedge clk) begin
        ret <= ret_next_;
        t0 <= t0_next_;
        t1 <= t1_next_;
      end
    endmodule

# クロック信号名は、コンバータスクリプトの CLKNAME 定数で
# カスタマイズできます。

--------------------
[A.3] 階層設計記述例
--------------------

innerproduct() の親ルーチンが次のような C コードだったとします。

    double sample(double a[2], double b[2], double c[2]) {
      double t[2];
      t[0] = a[0] + b[0];
      t[1] = a[1] + b[1];
      return innerproduct(t[0], t[1], c[0], c[1]);
    }

これを固定小数点化して、次のようにビット数が決まったとします。

    int sample(uint a[2], uint b[2], int c[2]) {
      uint t[2];
      int  ret;
      //  a[0],a[1] : unsigned, total 9bit,  fraction 6bit
      //  b[0],b[1] : unsigned, total 11bit, fraction 8bit
      //  t[0],t[1] : unsigned, total 12bit, fraction 8bit
      //  c[0],c[1] : signed,   total 14bit, fraction 7bit
      //  ret   : signed,   total 15bit, fraction 3bit
      t[0] = fix_add(a[0], U,9,6, b[0], U,11,8, U,12,8);
      t[1] = fix_add(a[1], U,9,6, b[1], U,11,8, U,12,8);
      ret = innerproduct(t[0], t[1], c[0], c[1]);
      return ret;
    }

この回路を、FDFL では次のように書くものとします。

    module sample
    i u 9 6 a0 a1
    i u 11 8 b0 b1
    i s 14 7 c0 c1
    w u 12 8 t0 = a0 + b0
    w u 12 8 t1 = a1 + b1
    o s 15 3 ret
    m innerproduct t0 t1 c0 c1 ret
    endmodule

# "m" は module instantiation を表します。

コンバート後の Verilog コードは次のようになります。

    module sample(a0,a1,b0,b1,c0,c1,ret);
      input   [8:0] a0;                     // U[3,6]
      input   [8:0] a1;                     // U[3,6]
      input  [10:0] b0;                     // U[3,8]
      input  [10:0] b1;                     // U[3,8]
      input  [13:0] c0;                     // S[7,7]
      input  [13:0] c1;                     // S[7,7]
      output [14:0] ret;                    // S[12,3]
      wire   [11:0] t0;                     // U[4,8]
      wire   [11:0] t1;                     // U[4,8]
      fix_adduu #(3,6,3,8,4,8) add0(a0, b0, t0);
      fix_adduu #(3,6,3,8,4,8) add1(a1, b1, t1);
      innerproduct innerproduct0(t0,t1,c0,c1,ret);
    endmodule

モジュールはすでに宣言／定義されたものでなくてはいけません。
つまり、FDFL コードはボトムアップスタイルに書かなければなりません。

=============
[B] FDFL 構文
=============

FDFL のシンタックスは、行・フィールド指向です。

1 行に 1 項目ずつ書くものとします。

フィールドの区切りは空白です。したがって、"t0=a0*b0" などと勝手に空白
を省略してはいけません。

# 空白はスペースでもタブでも構いませんし、空白の数は問いません。

NG 例 1:

  module innerproduct
  i u 12 8 a0 a1; i s 14 7 b0 b1
  …(中略)…
  endmodule

NG 例 2:

  module innerproduct
  i u 12 8 a0 a1
  i s 14 7 b0 b1
  w s 15 4 t0=a0*b0
  …(中略)…  
  endmodule

--------------------
[B.1] プリプロセッサ
--------------------

FDFL を Verilog に変換するコンバータは、プリプロセッサを内蔵します。プ
リプロセッサ構文は、FDFL で表現可能な機能を拡張するものではありません
が、見た目を簡潔にするのに大いに役立ち、生産性向上に寄与します。

本節では、プリプロセッサが何をどういう順で処理するか、という視点にたっ
て、プリプロセッサ構文を説明します。

[B.1.1] コメント削除
^^^^^^^^^^^^^^^^^^^^
プリプロセッサは、まずコメントを削除します。

FDFL のコメントは、次のいずれかです。

  (1) "#" で始まる行全体。
  (2) 1 行のうち、「1個以上の空白＋"#"」という部分から行末まで。

コメント使用例：

    module innerproduct
    # calculate innerproduct of 2-dimensional vectors
    i u 12 8 a0 a1
    i s 14 7 b0 b1
    w s 15 4 t0 = a0 * b0    # discard lower 11bits of the product
    w s 15 4 t1 = a1 * b1
    o s 15 3 ret = t0 + t1
    endmodule

[B.1.2] 空行削除
^^^^^^^^^^^^^^^^
次に、プリプロセッサは空行を行ごと削除します。

[B.1.3] ループ行展開
^^^^^^^^^^^^^^^^^^^^
次に、プリプロセッサはループ行を展開します。

ループ行は、

   <行の本体>    [<ループ先頭値>:<ループ末尾値>,…]

とか

   <行の本体>    [<インデックス値1>,<インデックス値2>,…]

という形で記述しします。「先頭値と末尾値のペア」と「単体のインデックス
値」を自由にミックスしてカンマで区切って並べることができます。

ループインデックスは、<行の本体> の中では # と書きます。たとえば、

   w s 15 4 t# = a# * b#        [0:3,5,7:9]

と書けば、

   w s 15 4 t0 = a0 * b0
   w s 15 4 t1 = a1 * b1
   w s 15 4 t2 = a2 * b2
   w s 15 4 t3 = a3 * b3
   w s 15 4 t5 = a5 * b5
   w s 15 4 t7 = a7 * b7
   w s 15 4 t8 = a8 * b8
   w s 15 4 t9 = a9 * b9

と書いたのと同じになります。

多重ループは書けません。

ループ先頭値やループ末尾値やインデックス値は 10 進の非負定数で
書くものとします。

ループ末尾値は、ループ先頭値より小さくてもかまいません。

先頭値と末尾値のペアを指定するときは、桁数を揃えることができます。
たとえば [0:15] というループの場合は、ループインデックスは
    0 1 2 3 … 14 15
となります。一方、[00:15] と書けば、ループインデックスは
    00 01 02 03 … 14 15
となります。[15:0] や [15:00] だと逆順になります。この桁数合わせは、
「先頭値と末尾値のペア」ごとに独立です。

<行の本体> の中ではループインデックスを # と書けるほか、
「ループインデックス+1」を $ と書くこともできます。たとえば

   w s 15 4 t0 = a + b
   w s 15 4 t$ = t# + c#	[0:2]

と書けば、

   w s 15 4 t0 = a + b
   w s 15 4 t1 = t0 + c0
   w s 15 4 t2 = t1 + c1
   w s 15 4 t3 = t2 + c2

と書いたのと同じになります。

# それ以上の機能は、(たまたま必要なかったので) サポートしてません。

# 「$」が「$signed(...)」や「$unsigned(...)」という文脈で
# 使われている場合は、「ループインデックス+1」とはみなしません。

ループ行のコンバート中にエラーが起きると、

  sample.df:125(loop=0): syntax error.

という感じで、ファイル名＆行番号に加えてループインデックスも表示されま
す。ただ、エラーが起きる場合はたいていは loop=0 と表示されるでしょう。

[B.1.4] フィールド分解
^^^^^^^^^^^^^^^^^^^^^^
次に、プリプロセッサは、ループ展開後の各行を、フィールドに分解します。

空白 (スペースやタブ) を区切り文字として awk,perl,ruby のように split
するだけです。

# 行頭の空白は無視されます。

[B.1.5] レンジ付きフィールド展開
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
最後に、プリプロセッサはレンジ付きフィールドの展開を行います。

レンジ付きフィールドとは、

    foo[00-15]bar

のような感じのフィールドで、このようなフィールドは

    foo00bar foo01bar foo02bar … foo14bar foo15bar

というふうに複数のフィールドに展開されます。

# ループ行と同様に、先頭値末尾値のペアや単独の値をカンマで区切って
# 自由に並べることができます。

foo の部分や bar の部分は無くてもかまいません。

レンジ先頭値とレンジ末尾値は 10 進の非負定数で書くものとします。

レンジ末尾値は、レンジ先頭値より小さくてもかまいません。

先頭値と末尾値のペアを指定するときは、桁数を揃えることができます。
たとえば [0-15] というレンジの場合は、レンジインデックスは
    0 1 2 3 … 14 15
となります。一方、[00-15] と書けば、レンジインデックスは
    00 01 02 03 … 14 15
となります。[15-0] や [15-00] だと逆順になります。この桁数合わせは、
「先頭値と末尾値のペア」ごとに独立です。

1 つのフィールドに複数のレンジを書いてもかまいません。C言語の多次元配
列と同じ順序で展開されます。

レンジ付きフィールド使用例：
    module sel16to1
    i u 8 0 dat[00-15,20,22-23]
    i u 4 0 sel
    o u 8 0 ans
    …(中略)…
    endmodule

--------------------------
[B.2] モジュール宣言／定義
--------------------------

プリプロセス後の FDFL コードは、モジュール宣言またはモジュール定義を並
べたものになります。

<モジュール宣言> ::= <module行> <入出力信号宣言行>+ <endmodule行>

<モジュール定義> ::= <module行> <module本体行>+ <endmodule行>

<module行>       ::= "module" <モジュール名>
<endmodule行>    ::= "endmodule"

<module本体行> ::= <入出力信号宣言行>
                 | <出力信号定義行>
                 | <中間信号宣言行>
                 | <中間定義行>
                 | <インスタンス生成行>
                 | <代入行>

モジュール宣言は、たとえば

    module innerproduct
    i u 12 8 a0 a1
    i s 14 7 b0 b1
    o s 15 3 ret
    endmodule

のように、モジュール名と I/O ポートの宣言だけを記述したものです。

これを Verilog コードにコンバートすると、

    // module innerproduct(...);  [externally defined]

という感じの Verilog コメントになります。Verilog コメントに書いてある
とおり、「宣言」されたモジュールは別ファイルで定義するものとします。別
ファイルでありさえすれば、FDFL で定義しても Verilog コードを手で書いて
もかまいません。

# 1 つの FDFL ファイルの上の方で forward 宣言しておいて下のほうで実体
# 定義する、というのは、(たまたま必要なかったので) サポートしていません。

--------------
[B.3] 信号の型
--------------

<信号型>          ::= <符号> <総ビット数> <小数部ビット数>
                    | "b"
<符号>            ::= "u" | "s"
<総ビット数>      ::= <10進非負定数> | <パラメータID>
<小数部ビット数>  ::= <10進定数(負でも良い)> | <パラメータID>

FDFL で扱う信号の型は、以下の 3 つに分類されます。

  符号付き固定小数点数
  符号無し固定小数点数
  boolean

固定小数点数型は、「符号、総ビット数、小数部ビット数」という 3 つのフィー
ルドで表すものとします。符号は "s" か "u" です。

boolean 型は "b" で表すものとします。

整数は、「小数部 0bit の固定小数点数」と考えます。

例：
    module sel2to1
    i u 8 0 dat0 dat1
    i b sel
    o u 8 0 ans
    …(中略)…
    endmodule

boolean 型は、「1bit の符号無し整数 (つまり u 1 0)」とほぼ等価です。
ただし、サブモジュールのインスタンスを使う時に、boolean ポートに u 1 0 
信号をつないだり、u 1 0 ポートに boolean 信号をつないだりすることは
できません。

# そのほうがポート順序指定ミスを検出しやすいだろうと思ったので
# そのような仕様にしたのですが、不便といえば不便なので、将来
# 仕様変更するかもしれません。

<パラメータID> については [B.8] 節で説明します。

----------------------------------------
[B.4] 入出力信号や中間信号の宣言／定義
----------------------------------------

<入出力信号宣言行> ::= <"i"または"o"または"q"> <信号型> <信号名>+
<中間信号宣言行>   ::= <"w"または"r"> <信号型> <信号名>+
<信号名>           ::= <Verilogで有効な識別子>

入出力宣言行は、以下のように "i" または "o" または "q" で始まる行です。

    i u 12 8 a0 a1
    i s 14 7 b0 b1
    i b sel
    o u 10 3 ans0 ans1
    q b valid

"i" は入力ワイヤ、"o" は出力ワイヤ、"q" は出力レジスタです。

中間信号宣言行は、以下のように "w" または "r" で始まる行です。

    w s 14 7 t0 t1
    r b ctrl

"w" は中間信号ワイヤ、"r" は中間信号レジスタです。

出力信号や中間信号は、宣言と同時に定義することもできます。

<出力信号定義行>  ::= <"o"または"q"> <信号型> <信号名> "=" <式>
                    | <"o"または"q"> <信号型> <信号名リスト> "=" <信号名リスト>
<中間信号定義行>  ::= <"w"または"r"> <信号型> <信号名> "=" <式>
                    | <"w"または"r"> <信号型> <信号名リスト> "=" <信号名リスト>

信号定義行の例

    w u 12 8 t0 = a0 + a1
    o s 15 3 ret = t0 + t1
    w u 10 6 s[0-1] = a[0-1]

出力レジスタや中間レジスタの場合、「定義」では「レジスタの D 入力信号
をどう作るか」を述べるものとします。出力レジスタや中間レジスタを式など
の中で「参照」すると、「レジスタの Q 出力信号」を意味します。

定義する信号が 1 つなら、代入の右辺に式を書くことができます。定義する
信号が複数の場合、代入の右辺に同数の信号名を書くことができます。複数定
義の場合、右辺に式を書けないので使い道は限定されますが、複数の信号のビッ
ト数を一括して変更したり、複数の信号を一括してパイプラインレジスタに投
入したりすることができます。

レジスタ信号をコンバートすると、1 つの FDFL レジスタ信号につき、2 つの 
Verilog 変数が生成されます。1 つは、FDFL レジスタ信号名そのものの reg 
変数で、Verilog レジスタの Q 出力信号を表します。もう 1 つは、FDFL レ
ジスタ信号名に "_next_" をつけた wire 変数で、Verilog レジスタの D 入
力信号を表します ([A.2] 節の具体例参照)。

--------
[B.5] 式
--------

FDFL での式は、以下の単純な形式に限られます。

<式> ::= <型変換式>
       | <空白無しVerilog式>
       | <ビット連結式>
       | <四則演算式>
       | <符号反転式>
       | <比較演算式>
       | <定数シフト演算式>
       | <マスク論理演算式>
       | <選択演算式>
       | <関数呼び出し風インスタンス生成式>

<型変換式>          ::= <信号名>
<空白無しVerilog式> ::= <信号名とみなせない1個のフィールド>
<ビット連結式>      ::= "{" <フィールド>+ "}"
<四則演算式>        ::= <信号名> <四則演算子> <信号名>
<符号反転式>        ::= "-" <信号名>
<比較演算式>        ::= <信号名> <比較演算子> <信号名>
<定数シフト演算式>  ::= <信号名> <シフト演算子> <10進非負定数>
<マスク論理演算式>  ::= <マスクパターン> <マスク論理演算子> <信号名>
<選択演算式>        ::= <フィールド> "?" <信号名> ":" <信号名>
<四則演算子>        ::= "+" | "-" | "*" | "/"
<比較演算子>        ::= "<" | ">" | "<=" | ">="
<シフト演算子>      ::= "<<" | ">>"
<マスク論理演算子>  ::= "&" | "^"
<マスクパターン>    ::= <"{{"と"}}"で囲まれたフィールド>

<関数呼び出し風インスタンス生成式>
    ::= <サブモジュール呼び出し名> "(" <実引数信号名>+ ")"

式の利用例

    w u 15 7 t00 = a0        # ビット数の調節を行う
    w u 15 7 t01 = (a0)      # (a0) がそのまま Verilog コードになる
    w u 15 7 t02 = a0[16:1]  # a0[16:1] がそのまま Verilog コードになる
    w u 15 7 t03 = a0+b0     # a0+b0 がそのまま Verilog コードになる
    w u 15 7 t04 = a0 + b0   # ビット数を考慮して fix_add() を行う
    w u 15 7 t05 = a0 - b0
    w u 15 7 t06 = a0 * b0
    w u 15 7 t07 = a0 / b0
    w s 15 7 t08 = - a0             # 符号反転
    w u 15 7 t09 = { ~a0[15] b0 }   # {~a0[15],b0} という Verilog コードになる
    w u 15 7 t10 = a0 < b0
    w u 15 7 t11 = a0 > b0
    w u 15 7 t12 = a0 <= b0
    w u 15 7 t13 = a0 >= b0
    w u 15 7 t14 = a0 << 2          # 小数点位置をずらす
    w u 15 7 t15 = a0 >> 2          # 小数点位置をずらす
    w u 15 7 t16 = {{a0[7]}} & b0   # {15{a0[7]}} & b0 になる
    w u 15 7 t17 = {{a0[7]}} ^ b0   # {15{a0[7]}} ^ b0 になる
    w u 15 7 t18 = a0[7] ? b0 : c0  # a0[7] ? b0 : c0 になる

C 言語などとの大きな違いは、「t = a * b + c」みたいな複雑な式を扱えな
いということです。これは手抜きではありません。「t = a * b + c」と書く
だけでは a*b という中間信号のビット数(総ビット数と小数部ビット数)がわ
からないので、Verilog にコンバートできないのです。したがって、そのよう
な式を認めるわけにはいきません。

<信号名> となっているオペランドは、信号の型をコンバータが認識して型チェッ
クや型調整を行います。「信号名」でなく「フィールド」となっているところ
は、型チェックや型調整を行わずにそのまま Verilog コードになります。

型変換式をコンバートすると、必要に応じて 0 パディングや符号拡張を行う
Verilog の concatenation 式になります。

空白無し Verilog 式をコンバートすると、そのまま Verilog コードになりま
す。これを使えば、Verilog で書ける "式" は何でも FDFL で書けます。ただ
し、case 文みたいな Verilog "文" は FDFL では書けないので、本格的な 
LSI を全部 FDFL だけで書くのは無謀です。

ビット連結式をコンバートすると、単純に Verilog のビット連結式になります。
中身は「フィールド」扱いで型チェックや型調整が行われないので、
    w u 15 7 t08 = { ~a0[15] b0 }   # ビット連結式
と書こうが
    w u 15 7 t08 = {~a0[15],b0}     # 空白無しVerilog式
と書こうが同じことです。ただ、ビット連結式なら、プリプロセッサの「レン
ジ付きフィールド展開機能」を活用して
    w u 64 0 all = { tmp[15-00] }
みたいな技を使うことができ、
    w u 64 0 all = {tmp15,tmp14,tmp13,…(中略)…,tmp01,tmp00}
と書くよりもタイプ量を減らせます。

# ビット連結式の中身が全て変数名である場合は、左右オペランドの
# 総ビット数が一致しているかどうかを、コンバータがチェックします。

四則演算式をコンバートすると、fix_addXX,fix_subXX,fix_mulXX,fix_divXX 
というサブモジュールのインスタンス生成コードになります。XX はオペラン
ドの符号で ss とか su とか us とか uu とかになります。

符号反転式をコンバートすると、fix_negX というサブモジュールのインスタ
ンス生成コードになります。X はオペランドの符号で、s または u です。

比較演算式をコンバートすると、fix_cmpltXX,fix_cmpgtXX,fix_cmpleXX,
fix_cmpgeXX というサブモジュールのインスタンス生成コードになります。

定数シフト演算式をコンバートすると、「assign dst = src;」という、no
operation の Verilog コードになります。つまり、具体的な演算は行わず、
小数点位置の解釈だけを変えます。…ですから、dst のビット数と src のビッ
ト数とシフト量との間に以下の関係が成り立っていなければなりません (さも
ないとコンバートエラーになります)。

   dstの符号 ＝ srcの符号
   dstの総ビット数 ＝ srcの総ビット数
   dstの小数部ビット数 ＝ srcの小数部ビット数 − 左シフト量
                                    (右シフトの場合は＋)

定数シフト演算式の利用例

   浮動小数点 C コード：
     t = a * 3.0;

   固定小数点 C コード：
     t = fix_mul(a, U,12,4, 3, U,2,0, U,10,1);

   FDFL コード：
     i u 12 4 a
     w u 12 3 a2 = a << 1
     o u 10 1 t = a2 + a

マスク論理演算式をコンバートすると、繰り返し式を使ってマスクパターンを
生成してから右オペランド信号と bitwise AND または bitwise XOR を行う、
という Verilog コードになります。右オペランド信号と destination 信号の
型は一致していなければなりません。マスクパターンの元となるマスク値は、
boolean 信号であることを想定していますが、「a0[7]」みたいに FDFL 管轄
外の Verilog コードを柔軟に書けるようにするため、型チェックは行ってい
ません。

選択演算式をコンバートすると、素直に Verilog の ?: 式になります。選択
条件部は、boolean 信号であることを想定していますが、「a0[7]」みたいに 
FDFL 管轄外の Verilog コードを柔軟に書けるようにするため、型チェックは
行っていません。一方、then オペランドと else オペランドについては、
destination 信号と型が一致しているかどうかチェックします。チェックをし
てほしくなければ、
    w u 15 7 t17 = a0[7] ? b0 : c0      # 選択演算式
でなく
    w u 15 7 t17 = a0[7]?b0:c0          # 空白無しVerilog式
と書けばいいのです。

関数呼び出し風インスタンス生成式をコンバートすると、実引数信号リストの
末尾に destination 信号名を追加したインスタンス生成コードになります。
たとえば、

    o s 15 3 ret = innerproduct ( t0 t1 c0 c1 )

と書くと、

    innerproduct innerproduct0(t0,t1,c0,c1,ret);

という Verilog コードになります。

どの式においても、オペランドで使う「信号名」は、宣言済みないし定義済み
でなければなりません。関数呼び出し風インスタンス生成式におけるサブモ
ジュール名も、宣言済みないし定義済みでなければなりません。

----------------------
[B.6] インスタンス生成
----------------------

<インスタンス生成行> ::= "m" <サブモジュール呼び出し名> <信号名>+

<サブモジュール呼び出し名>
    ::= <サブモジュール名>
      | <明示的インスタンス名付きサブモジュール名>
      | <明示的パラメータリスト付き外部サブモジュール名>
      | <明示的パラメータリスト&明示的インスタンス名付き外部サブモジュール名>

<サブモジュール名> ::= <宣言済みまたは定義済みのモジュール名>

インスタンス生成行は、次のように "m" で始まる行です。

    m innerproduct t0 t1 c0 c1 ret

サブモジュール名に比き続いて、実引数信号名を並べます。

仮引数と実引数の型は一致していなくてはなりません。

FDFL では原則的に「インスタンス名」は指定しません。コンバータが自動で
「サブモジュール名＋番号」というインスタンス名を生成します。番号は、
「呼び出しモジュール内において、それまでにそのサブモジュールをいくつ生
成したか」を表す番号です。サブモジュール名が数字で終わる場合は、サブモ
ジュール名と番号との間にアンダースコアが挿入されます。

Verilog コード(インスタンス名自動生成)例：

    innerproduct innerproduct0(...);
    innerproduct innerproduct1(...);
    innerproduct innerproduct2(...);
    sel16to1 sel16to1_0(...);
    sel16to1 sel16to1_1(...);
    sel16to1 sel16to1_2(...);

# インスタンス名は、コンバータスクリプト冒頭の abbrev_instance_name
# 関数でカスタマイズできます。

例外的に、FDFL コードでインスタンス名を手動指定することもできます。
たとえば、FDFL で

    m innerproduct:u_inpr ...

と書けば、コンバート後の Verilog コードでは u_inpr というインスタンス
名になります。「サブモジュール名」フィールドの代わりに「インスタンス名
付きサブモジュール名」を書く、という解釈なので、コロンの前後に空白を
いれてはいけません。

手動指定のインスタンス名と自動指定のインスタンス名が衝突しないようにす
るのは、ユーザの責任です。コンバータは、手動指定インスタンス名について
は「インスタンス名らしいかどうか」のチェックしかしません。

# 論理合成の際にインスタンス名に基づいて ungroup などの一括処理を
# したい場合、インスタンス名を手動指定すると便利です。

「明示的パラメータリスト付き外部サブモジュール名」については
[B.8.2] 節で説明します。

----------
[B.7] 代入
----------

<代入行> ::= "m" <信号名> "=" <式>
           | "m" <信号名リスト> "=" <信号名リスト>
           | "m" "{" <信号名リスト> "}" "=" <フィールド>

代入行は、次のように "m" で始まる行です。

    m ret = innerproduct ( t0 t1 c0 c1 )

この例のように「関数呼び出し風サブモジュールインスタンス生成」を主用途
と想定したので、インスタンス生成行と同じ "m" で始まるシンタックスにし
ました。しかし、<式> は任意の式でいいので、

    m t0 = a0 + b0

とか

    m t0 = a0[7] ? b0 : c0

とかも書けます。a0 + b0 は「fix_add インスタンス生成」とこじつけること
もできますが、a0[7] ? b0 : c0 となるともはやインスタンス生成ではないの
で、"m" で始まるのは違和感があるかもしれません。

それはともかく、代入行を活用すれば、たとえば

    w u 15 7 t0 = a + b
    w u 15 7 t1 = a - b

の代わりに

    w u 15 7 t0 t1
    m t0 = a + b
    m t1 = a - b

と書くことができるので、信号ビット数の変更が楽になります。

代入する信号が 1 つなら、右辺に式を書くことができます。代入する信号が
複数の場合、

   m bvec[0-3] = avec[0-3]

のように、右辺に同数の信号名を書くことができます。複数代入の場合、右辺
に式を書けないので使い道は限定されますが、複数の信号のビット数を一括し
て変更したり、複数の信号を一括してパイプラインレジスタに投入したりする
ことができます。

ビット連結の逆の操作 (ビット分解) を行いたい場合は第 3 の構文を使う
ことができます。たとえば

   m { bvec[0-3] } = allbvec

という感じで書けます。右辺に書けるのは変数名か Verilog 式 (FDFL にとって
パーズ不能なフィールド) です。右辺が変数名の場合は、左辺と右辺の総ビット数
が同じかどうかをコンバータが自動でチェックします。右辺が Verilog 式の場合は、
コンバータは総ビット数のチェックをせず単純に Verilog コードに変換します。

------------------------------
[B.8] パラメータ付きモジュール
------------------------------

[B.8.1] パラメータ付きモジュールの定義と利用
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
FDFL では、信号のビット数をパラメータ化することができます。

[B.3] 節において、信号の総ビット数や小数部ビット数は 10進定数
または <パラメータID> だ、と述べました。<パラメータID> は、
"@A" や "@B" といった形で表します。

<パラメータID> = "@A" | "@B" | "@C" | …(中略)… | "@Z"

使用例：

    module sel2to1
    i u @A @B d0 d1
    i b sel
    o u @A @B ans = sel ? d1 : d0
    endmodule

    module sel2to1cast
    i u @A @B d0 d1
    i b sel
    w u @A @B tmp = sel ? d1 : d0
    o u @C @D ans = tmp
    endmodule

sel2to1 は、単純な 2-to-1 セレクタです。sel2to1cast は、出力の型が入力
の型と違っても構わない、型変換機能付きの 2-to-1 セレクタです。

# この例は unsigned 限定です。unsigned か signed かをパラメータ化する
# ことはできません。

パラメータは 1 モジュール当たり最大 26 種類までしか使えません。

パラメータ付きモジュールを使う(インスタンス生成する)には、

    module use_sel2to1
    i u 13 5 d0 d1
    i u 14 8 d2 d3
    i b sel
    o u 13 5 ans0 = sel2to1 ( d0 d1 sel )
    o u 14 8 ans1 = sel2to1 ( d2 d3 sel )
    endmodule

というふうに、普通にインスタンス生成すれば OK です。パラメータの実際の
値は、実引数と仮引数のマッチ処理を行ってコンバータが自動で決めます。

# パラメータ付きモジュールを定義する際は、実引数と仮引数のマッチ処理を
# 行うだけで全てのパラメータが確定できるようになっていなければなりませ
# ん。たとえば、
#
#    module bad_sample
#    i u @A @B d0 d1
#    w u @C @D tmp1 = d0 * d0
#    w u @C @D tmp2 = d1 * d1
#    o u @E @F ans = tmp1 + tmp2
#    endmodule
#
# というようなモジュールは、インスタンス生成時に実引数と仮引数のマッチ
# 処理を行っても @C,@D の値が確定できないので、NG です。

パラメータ付きモジュールをコンバートすると、Verilog の parameter 構文
になります…、といいたいところですが、実はそうはなりません。コンバータ
の手抜きのせいです。コンバータは、パラメータ付きモジュール定義に出くわ
すと、すぐに Verilog コードに変換せずに、いったんメモリに FDFL コード
のまま溜めておきます。そして、以降のモジュールがそのモジュールをインス
タンス生成してパラメータの具体的な値が確定したら、メモリ内の FDFL コー
ドを引っ張りだしてきてパラメータ部分を具体的数値に書き換えて、パラメー
タ無し Verilog コードを生成します。

# コンバータをそういう造りにすれば、パラメータ付きモジュール内の式の型
# チェックや、パラメータ付きモジュール内でさらにサブモジュールをインス
# タンス生成しているときの引数型マッチ処理が、楽になるのです。

たとえば、上記 use_sel2to1 モジュールをコンバートすると、次のような 
Verilog コードになります。

    module use_sel2to1(d0,d1,d2,d3,sel,ans0,ans1);
      input  [12:0] d0;                     // U[8,5]
      input  [12:0] d1;                     // U[8,5]
      input  [13:0] d2;                     // U[6,8]
      input  [13:0] d3;                     // U[6,8]
      input         sel;
      output [12:0] ans0;                   // U[8,5]
      output [13:0] ans1;                   // U[6,8]
      sel2to1_A13B5 sel2to1_0(d0,d1,sel,ans0);
      sel2to1_A14B8 sel2to1_1(d2,d3,sel,ans1);
    endmodule
    
    module sel2to1_A13B5(d0,d1,sel,ans);
      input  [12:0] d0;                     // U[8,5]
      input  [12:0] d1;                     // U[8,5]
      input         sel;
      output [12:0] ans;                    // U[8,5]
      assign ans = sel ? d1 : d0;
    endmodule
    
    module sel2to1_A14B8(d0,d1,sel,ans);
      input  [13:0] d0;                     // U[6,8]
      input  [13:0] d1;                     // U[6,8]
      input         sel;
      output [13:0] ans;                    // U[6,8]
      assign ans = sel ? d1 : d0;
    endmodule

異なるパラメータセットを区別するために、コンバータは、sel2to1_A13B5 と
か sel2to1_A14B8 という感じにモジュール名を自動修飾します。

# A14B8 というのは、@A パラメータが 14 で @B パラメータが 8 ということ
# を意味します。パラメータが負のときは、A14Bm5 (@A=14,@B=-5) のように
# 修飾します。

パラメータは、信号のビット数のところでしか使えません。<式> の中で使う
ことはできません (コンバータの手抜き)。信号ビット数としては「10 進定数」
か「パラメータ ID そのもの」しか指定できないので、@A+1 など「パラメー
タを加工したもの」は指定できません。

[B.8.2] パラメータ付きモジュールの宣言と利用
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
外部定義のモジュール (FDFL でなく Verilog で直接定義するモジュール) を
FDFL から利用する場合、FDFL では「モジュール宣言してから利用」することに
なりますが、外部定義モジュールがパラメータを持つことがあり得ます。

パラメータに応じて入出力信号のビット数が変わる場合は、FDFL でのモジュー
ル宣言も、[B.8.1] 節の @A,@B… という構文を使うことになります。パラメー
タと入出力信号ビット数が無関係な場合は、FDFL でのモジュール宣言は、
パラメータ無しモジュールのような見た目になります。

いずれの場合も、利用する際に、パラメータを明示的に指定することができます。
たとえば、外部 Verilog コードとして

    module generic_8bit_counter(clk, rst, q);
    parameter INIT = 8'h00;
    parameter MAX = 8'hff;
    input clk, rst;
    output [7:0] q;
    ...;
    endmodule

という「初期値や上限値をカスタマイズ可能な 8bit カウンタ」が定義されて
いる場合、FDFL では

    module generic_8bit_counter
    i b     rst
    q u 8 0 q
    endmodule

    module use_generic_8bit_counter
    ...
    m generic_8bit_counter(8'h10,8'hf0) rst cnt
    ...
    endmodule

と書いて宣言＆利用することができます。この FDFL コードをコンバートすると

    module use_generic_8bit_counter(...);
    ...;
    generic_8bit_counter #(8'h10,8'hf0) generic_8bit_counter_0(clk,rst,cnt);
    ...;
    endmodule

という Verilog コードになります。FDFL においては、「<サブモジュール名>
フィールドの代わりに、<パラメータリスト付き外部サブモジュール名>フィー
ルドを書く」という構文なので、空白をはさんではいけません。

あるいは、外部 Verilog コードとして

    module generic_counter(clk, rst, q);
    parameter W = 8;
    parameter INIT = 8'h00;
    parameter MAX = 8'hff;
    input clk, rst;
    output [W-1:0] q;
    ...;
    endmodule

という「ビット数と初期値と上限値をカスタマイズ可能なカウンタ」が
定義されている場合、FDFL では

    module generic_counter
    i b      rst
    q u @A 0 q
    endmodule

    module use_generic_counter
    ...
    m generic_counter(8,8'h10,8'hf0) rst cnt
    ...
    endmodule

と書いて宣言＆利用することができます。この場合 cnt が 8bit でなくても
コンバータは文句を言わないので、Verilog lint ツール等できちんと確認
する必要があります。

FDFL のパラメータ付きモジュール宣言と外部 Verilog コードのパラメータが
素直に対応している場合は、FDFL でモジュールを利用する際にパラメータリ
ストを省略することができます。そのときは、コンバータが @A,@B,… の順で
自動的にパラメータリストを生成します。たとえば、[B.8.1] 節の sel2to1 
が外部定義のモジュールだった場合、外部定義の Verilog コードを

    module sel2to1(d0,d1,sel,ans);
    parameter W = 1;   // total bitwidth
    parameter F = 0;   // fractional bitwidth (unused)
    input  [W-1:0] d0, d1;
    input          sel
    output [W-1:0] ans = sel ? d1 : d0;
    endmodule

としておけば、FDFL でのモジュール宣言

    module sel2to1
    i u @A @B d0 d1
    i b sel
    o u @A @B ans
    endmodule
    # @A is the first parameter.  @B is the second parameter.

とうまく対応が取れるので、FDFL で利用する際は [B.8.1] 節と同じように

    module use_sel2to1
    i u 13 5 d0 d1
    i u 14 8 d2 d3
    i b sel
    o u 13 5 ans0 = sel2to1 ( d0 d1 sel )
    o u 14 8 ans1 = sel2to1 ( d2 d3 sel )
    endmodule

と(パラメータリストを省略して)書くことができます。これをコンバートすると、
コンバータがパラメータリストを自動生成して、

    module use_sel2to1(d0,d1,d2,d3,sel,ans0,ans1);
      input  [12:0] d0;                     // U[8,5]
      input  [12:0] d1;                     // U[8,5]
      input  [13:0] d2;                     // U[6,8]
      input  [13:0] d3;                     // U[6,8]
      input         sel;
      output [12:0] ans0;                   // U[8,5]
      output [13:0] ans1;                   // U[6,8]
      sel2to1 #(13,5) sel2to1_0(d0,d1,sel,ans0);
      sel2to1 #(14,8) sel2to1_1(d2,d3,sel,ans1);
    endmodule

という Verilog コードになります。

パラメータリストは、全部明示的に指定するか、全部自動生成させるか、の
どちらかです。一部を明示的に指定して残りを自動生成させる、ということは
できません。

パラメータリストとインスタンス名の両方を明示的に指定する場合は、

    m generic_counter(8,8'h10,8'hf0):u_cnt rst cnt

のように、パラメータリスト→インスタンス名の順番で指定します。

--------------------------
[B.9] ビルトインモジュール
--------------------------

FDFL には、いくつかのビルトインモジュールがあります。

ビルトインモジュールといっても、コンバータは「モジュールの存在をデフォ
ルトで知っており、必要に応じてインスタンス生成 Verilog コードを生成す
る」にすぎません。Verilog 定義コードについてはコンバータは関知しないの
で、別途作ってください。

[B.9.1] 演算子を実装するためのモジュール
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
四則演算式をコンバートすると、

    fix_addss,fix_addsu,fix_addus,fix_adduu
    fix_subss,fix_subsu,fix_subus,fix_subuu
    fix_mulss,fix_mulsu,fix_mulus,fix_muluu
    fix_divss,fix_divsu,fix_divus,fix_divuu

というモジュールのインスタンス生成コードになります。

suffix の ss,su,us,uu は、入力オペランドの符号を表します。

どのモジュールについても、以下のような Verilog 定義コードを別途作って
ください。

    module fix_addss(a,b,z);
      parameter AI = ???;    // a 入力の整数部ビット数(符号込み)
      parameter AF = ???;    // a 入力の小数部ビット数
      parameter BI = ???;    // b 入力の整数部ビット数(符号込み)
      parameter BF = ???;    // b 入力の小数部ビット数
      parameter ZI = ???;    // z 出力の整数部ビット数
      parameter ZF = ???;    // z 出力の小数部ビット数
      input [AI+AF-1:0]   a;
      input [BI+BF-1:0]   b;
      output [ZI+ZF-1:0]  z;
      assign z = ...;
    endmodule

特殊ケースとして、左オペランドと右オペランドが同じ乗算式 (要するに二乗
式) をコンバートすると、

    fix_squs または fix_squu

という 1 入力 1 出力のモジュールのインスタンス生成コードになります。し
たがって、以下のような Verilog 定義コードを別途作ってください。

    module fix_squs(a,z);
      parameter AI = ???;    // a 入力の整数部ビット数(符号込み)
      parameter AF = ???;    // a 入力の小数部ビット数
      parameter ZI = ???;    // z 出力の整数部ビット数
      parameter ZF = ???;    // z 出力の小数部ビット数
      input [AI+AF-1:0]   a;
      output [ZI+ZF-1:0]  z;
      assign z = ...;
    endmodule

符号反転式をコンバートすると、

    fix_negs,fix_negu

という 1 入力 1 出力モジュールのインスタンス生成コードになります。
fix_squs,fix_squu と同じ要領で Verilog 定義コードを別途作ってください。

比較演算式をコンバートすると、

    fix_cmpltss,fix_cmpltsu,fix_cmpltus,fix_cmpltuu,  (for < expression)
    fix_cmpgtss,fix_cmpgtsu,fix_cmpgtus,fix_cmpgtuu,  (for > expression)
    fix_cmpless,fix_cmplesu,fix_cmpleus,fix_cmpleuu,  (for <= expression)
    fix_cmpgess,fix_cmpgesu,fix_cmpgeus,fix_cmpgeuu,  (for >= expression)

というモジュールのインスタンス生成コードになります。

どのモジュールについても、以下のような Verilog 定義コードを別途作って
ください。

    module fix_cmpltss(a,b,z);
      parameter AI = ???;    // a 入力の整数部ビット数(符号込み)
      parameter AF = ???;    // a 入力の小数部ビット数
      parameter BI = ???;    // b 入力の整数部ビット数(符号込み)
      parameter BF = ???;    // b 入力の小数部ビット数
      input [AI+AF-1:0]   a;
      input [BI+BF-1:0]   b;
      output z;
      assign z = ...;        // a < b なら 1、そうでなければ 0
    endmodule

[B.9.2] 宣言無しでインスタンス生成できるモジュール
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
同時加減算器 addandsub とキャリーイン付き加算器 addci は、宣言無しでイ
ンスタンス生成できます。

使用例：

     module use_addandsub
     i u 12 4 a
     i s 11 3 b
     o u 12 2 sum
     o s 11 4 diff
     m addandsub a b sum diff
     endmodule

     module use_addci
     i u 12 4 a
     i s 11 3 b
     i b ci
     o u 11 4 ans = addci ( a b ci )   # ci は b の LSB と同じ重み
     endmodule

コンバートすると、

    fix_addandsubss,fix_addandsubsu,fix_addandsubus,fix_addandsubuu,
    fix_addciss,fix_addcisu,fix_addcius,fix_addciuu,

というモジュールのインスタンス生成コードになります。

以下のような Verilog 定義コードを別途作ってください。

    module fix_addandsubss(a,b,sum,diff);
      parameter AI = ???;    // a 入力の整数部ビット数(符号込み)
      parameter AF = ???;    // a 入力の小数部ビット数
      parameter BI = ???;    // b 入力の整数部ビット数(符号込み)
      parameter BF = ???;    // b 入力の小数部ビット数
      parameter SI = ???;    // sum 出力の整数部ビット数
      parameter SF = ???;    // sum 出力の小数部ビット数
      parameter DI = ???;    // diff 出力の整数部ビット数
      parameter DF = ???;    // diff 出力の小数部ビット数
      input [AI+AF-1:0]   a;
      input [BI+BF-1:0]   b;
      output [SI+SF-1:0]  sum;
      output [DI+DF-1:0]  diff;
      assign sum = ...;
      assign diff = ...;
    endmodule

    module fix_addciss(a,b,ci,z);
      parameter AI = ???;    // a 入力の整数部ビット数(符号込み)
      parameter AF = ???;    // a 入力の小数部ビット数
      parameter BI = ???;    // b 入力の整数部ビット数(符号込み)
      parameter BF = ???;    // b 入力の小数部ビット数
      parameter ZI = ???;    // z 出力の整数部ビット数
      parameter ZF = ???;    // z 出力の小数部ビット数
      input [AI+AF-1:0]   a;
      input [BI+BF-1:0]   b;
      input               ci;
      output [ZI+ZF-1:0]  z;
      assign z = ...;
    endmodule

========
[C] ToDo
========

------------------------
[C.1] レジスタ初期値指定
------------------------

現状の FDFL ではレジスタ初期値指定ができません。初期値指定をできるよう
にすれば、ステートマシンを組めるようになり、FDFL の応用範囲が広がりま
す。初期値指定の構文としては、

   r u 8 0 foo := 8'h2e

のような感じにするか、

   r u 8 0 foo(8'h2e) bar(8'hdc)

のような感じに拡張すればすんなりいくでしょう。あとはコンバータで初期値
指定構文をサポートするだけ。

--------------------------
[C.2] 入出力一貫性チェック
--------------------------

現状のコンバータは、インスタンス生成時に、FDFL 信号の型チェックをしま
すが、input/output の一貫性はチェックしません。つまり、「ある wire を
複数のゲートがドライブしている」とか「ある wire を誰もドライブしていな
い」などの矛盾があってもおかまいなしに Verilog コードを生成してしまい
ます。たとえば

    w s 15 3 ret
    m innerproduct ( t0 t1 c0 c1 ret )
    m innerproduct ( t2 t3 c2 c3 ret )

というのは人間が見れば一目で「ret を 2 個所でドライブしている(出力信号
衝突バグ)」とわかりますが、コンバータはエラーを出しません。

コンバータでこのエラーを検出するようにすれば、生産性がさらに向上します。
