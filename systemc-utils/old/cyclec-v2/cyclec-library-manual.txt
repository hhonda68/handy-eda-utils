#
# Lightweight functional digital logic simulator library.
#

# Copyright (c) 2008 the handy-eda-utils developer(s).
# Distributed under the MIT License.
# (See accompanying file COPYING or copy at
#  http://www.opensource.org/licenses/mit-license.php.)

# Last modified on October 2005.

サイクルベース回路シミュレーションライブラリ CycleC (2005/10/20)

[A] 概要
  [A.1] シミュレーションの特徴
  [A.2] シミュレーションの原理
[B] 基本的使用例
  [B.1] NAND ゲートのシミュレーション
    [B.1.1] テスト対象回路クラスを作る
    [B.1.2] テストジグクラスを作る
    [B.1.3] テストベンチクラスを作る
    [B.1.4] シミュレーションメインルーチンを書く
    [B.1.5] 信号を覗き見する
  [B.2] カウンターのシミュレーション
    [B.2.1] 構造記述バージョンを作る
    [B.2.2] RTL 記述バージョンを作る
    [B.2.3] ビヘイビア記述バージョンを作る
    [B.2.4] テストベンチクラスを作る
    [B.2.5] シミュレーションメインルーチンを書く
    [B.2.6] 信号を覗き見する
[C] 回路利用者向けリファレンス
  [C.1] CycleC::Port<T>
    [C.1.1] T get() const
  [C.2] CycleC::Circuit::Register<T>
    [C.2.1] T cur() const
  [C.3] CycleC::Circuit
    [C.3.1] 公開メンバ変数
    [C.3.2] std::string name() const
    [C.3.3] void evaluate(), void update(), void tick()
    [C.3.4] void reset()
[D] 階層無し回路実装者向けリファレンス
  [D.1] CycleC::Circuit::InPort<T>
    [D.1.1] InPort()
    [D.1.2] T get() const
  [D.2] CycleC::Circuit::CombOutPort<T>
    [D.2.1] HAS_COMBOUTPORT(circuit)
    [D.2.2] CombOut(port, func)
    [D.2.3] T get() const
  [D.3] Register<T>
    [D.3.1] Register(const T& initial_value = T())
    [D.3.2] T cur() const
    [D.3.3] void nxt(const T& next_value)
    [D.3.4] void cke(bool cke_value)
  [D.4] RegOutPort<T>
    [D.4.1] RegOutPort(const T& initial_value = T())
    [D.4.2] T get() const
    [D.4.3] T cur() const
    [D.4.4] void nxt(const T& next_value),  void cke(boolcke_value)
  [D.5] RegRefOutPort<T>
    [D.5.1] RegRefOut(port, ref)
    [D.5.2] T get() const
  [D.6] VarOutPort<T>
    [D.6.1] VarOutPort(const T& initial_value = T())
    [D.6.2] T get() const
    [D.6.3] void set(const T& value)
  [D.7] VarRefOut<T>
    [D.7.1] VarRefOut(port, ref)
    [D.7.2] T get() const
  [D.8] CycleC::Circuit
    [D.8.1] 公開メンバ変数
    [D.8.2] Circuit()
    [D.8.3] CycleC::Circuit::Name
    [D.8.4] std::string name() const
    [D.8.5] void evaluate_self(), void update_self()
    [D.8.6] void reset_self()
[E] 階層回路実装者向けリファレンス
  [E.1] CycleC::Circuit::InPort<T>
    [E.1.1] void connect(const Port<T>& src)
  [E.2] FwdOutPort<T>
    [E.2.1] FwdOutPort()
    [E.2.2] void connect(const Port<T>& src)
    [E.2.3] T get() const
  [E.3] CycleC::Circuit
[F] 発展技：多相クロック対応
  [F.1] CycleC における多相クロックシミュレーションの概要
  [F.2] 多相クロック回路シミュレーション例
    [F.2.1] 多相クロック回路クラスを作る
    [F.2.2] ビヘイビア記述バージョンを作る
    [F.2.3] ATPG とテストベンチクラスを作る
    [F.2.4] シミュレーションメインルーチンを書く
    [F.2.5] 信号を覗き見する
    [F.2.6] シミュレーションメインルーチンを楽に書く
  [F.3] CycleC::Circuit 追加リファレンス
    [F.3.0] プリプロセッサマクロ CYCLEC_MULTICLOCK
    [F.3.1] クロック番号集合ビットマップ型 clkmap_t
    [F.3.2] クラス変数 the_active_clock_map
    [F.3.3] メンバ変数 m_clockmap
    [F.3.4] メンバ手続き void assign_clock(int clknr)
  [F.4] ポートとレジスタの追加リファレンス
    [F.4.1] void tick()
  [F.5] CycleC::TimeKeeper リファレンス
    [F.5.1] TimeKeeper()
    [F.5.2] void define_clock(int id, uint period, uint start_time = 0)
    [F.5.3] void advance()
    [F.5.4] uint time() const
    [F.5.5] uint cycle(int clkid) const
    [F.5.6] clkmap_t clockmap() const
    [F.5.7] void reset()
  [F.6] 制限事項
[G] 使用済み名前リスト

========
[A] 概要
========

CycleC は、ゼロ遅延サイクルベースで単相クロック 2 値論理回路シミュレー
ションを行うための C++ クラスライブラリです。SystemC と比べ、機能を絞
りこんでいる分だけ高速です。

ファイル構成：
    cyclec.h    ヘッダファイル (namespace CycleC)
    cyclec.cc   ライブラリ本体

CycleC 利用者は、CycleC::Circuit クラスをベースに、自分の回路を継承記
述します。メンバ変数として入力ポートや出力ポートや内部レジスタを持ち、
出力ポート値の計算手続きや内部レジスタ更新計算手続きを定義すれば、回路
を定義したことになります。メンバ変数として他の回路インスタンスを持てば、
階層設計もできます。

----------------------------
[A.1] シミュレーションの特徴
----------------------------

CycleC のシミュレーションには、
    ゼロ遅延サイクルベース
    backward evaluation
    ユーザーによるクロック進行管理
という特徴があります。

ゼロ遅延サイクルベースというのは、世間の HDL シミュレータでおなじみの
概念です。

backward evaluation というのは、「組み合わせ論理部の評価を、出力段から
入力段に向けて行う」という意味です。世間の levelized compiled code サ
イクルベースシミュレータとは評価順序が逆になります。

  世間の levelized compiled code シミュレーションの各サイクル：
    FF 現在値 (Q出力端子) や入力信号の現在値から出発して、
    組み合わせ論理を入力段から出力段に向かって評価していく。
    評価が完了すれば、FF の次値 (D入力端子) や出力信号の値が
    求まっているはずである。

  CycleC の backward evaluation シミュレーションの各サイクル：
    FF の次値 (D入力端子) や出力信号の値の値を計算すべく、
    そこにつながっている組み合わせ論理を、出力段から入力段に
    向かって再帰的に評価していく。

backward evaluation は再帰処理なので性能面で不利に見えますが、セレクタ
なんかは SEL 信号を再帰評価したあと A と B の一方だけを再帰評価するだ
けですむので、無条件に全ロジックを評価する levelized compiled code シ
ミュレーションより有利な面もあります。それから、backward evaluation な
ら、わざわざ "compile" せずとも、回路定義の C++ ソースコードをそのまま
実行するだけでシミュレーションできる感じになります。

ユーザーによるクロック進行管理というのは、「SystemC のようにシミュレー
ション進行をライブラリに握られてしまうのではなく、HDL のようにユーザー
がテストベンチを記述して主体的にシミュレーション進行を管理する」という
ことです。ユーザーが主体的にクロックを進めますから、pause や 
breakpoint も自由自在です。

----------------------------
[A.2] シミュレーションの原理
----------------------------

「回路定義の C++ ソースコードをそのまま実行するだけでシミュレーション」
できるような感じにするため、CycleC のシミュレーションは以下の原理に基
づいて行います。

  ・システムは、回路インスタンスを相互接続したもの。

  ・各回路インスタンスは、「クロックサイクル中の処理」と「クロック
    サイクル切り替わり時の処理」を区別して実行する。

  ・クロックサイクル中の処理 (evaluate フェーズ) においては、
    入力ポートの状態を調べながら内部ステートの更新準備を行う。
    内部 FF の D 入力の値を確定させてどこかにメモしておく、という
    イメージ。

  ・クロックサイクル切り替わり時の処理 (update フェーズ) においては、
    入力ポートの状態を調べずに、内部ステートの更新作業を行う。
    evaluate フェーズでメモしておいた値を内部 FF の Q 出力として
    ラッチする、というイメージ。

  ・システムを 1 サイクル分シミュレーションする際は、全回路インス
    タンスを順不同で evaluate してから、全回路インスタンスを順不同で
    update する。このオペレーションを tick と呼ぶことにする。

このように evaluate フェーズと update フェーズを区別して記述しておけば、
HDL における「ノンブロッキング代入」を自然に実現できます。また、
「evaluate フェーズでは入力ポート状態を調べてもいいが内部ステートを変
えてはならない (当然出力ポート値も変えてはならない)」「update フェーズ
では内部ステート (や出力ポート値) を変えてもいいが、入力ポート状態を調
べてはならない」という取り決めをすることにより、システム全体をシミュレー
ションする際に、各回路インスタンスの接続依存関係を気にせず順不同で 
evaluate,update するだけでうまくいきます。

================
[B] 基本的使用例
================

CycleC の基本的な使い方は、

(1) テスト対象回路クラスを作る。
(2) テストジグクラスを作る。
(3) 両者を組み合わせて接続したテストベンチクラスを作る。
(4) テストベンチクラスのインスタンスを作ってシミュレーションする
    メインプログラムを書く。

となります。(1)〜(3) は全て回路クラスとして CycleC::Circuit を継承して
作ります。

-----------------------------------
[B.1] NAND ゲートのシミュレーション
-----------------------------------

基本中の基本として、NAND ゲートを CycleC で記述してシミュレーション
してみます。

[B.1.1] テスト対象回路クラスを作る
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
2 入力 NAND ゲートクラスを作ります。

    #include "cyclec.h"

    class NandGate : public CycleC::Circuit {
      HAS_COMBOUTPORT(NandGate);
    public:
      InPort<bool>          A, B;
      CombOutPort<bool>     X;
      NandGate(Name name) : CombOut(X, calcX) {}
    private:
      bool calcX() const { return !(A() && B()); }
    };

入力ポートが A,B で、出力ポートが X です。入力ポートは全て InPort<T> 
という型ですが、出力ポートは
    CombOutPort<T>   組み合わせ論理出力ポート
    RegOutPort<T>    レジスタ出力ポート
    FwdOutPort<T>    サブ階層回路の出力を forwarding するポート
などの種類があります。NAND ゲートの出力ポートは組み合わせ論理出力
なので CombOutPort<bool> 型にしました。

# 理論的には CombOutPort<T> さえあれば事足りるのですが、CombOutPort<T> 
# は記述がやや面倒なので、よく使うパターンを楽に記述できるようにするた
# め RegOutPort<T> 等の utility ポート型を用意してあります。

# CombOutPort<T> を使う時は、事前に HAS_COMBOUTPORT(ClassName); という
# お約束の宣言をしておく必要があります。忘れるとコンパイルエラーになり
# ます。

回路のコンストラクタは、Circuit::Name 型の引数を取るものとします。利用
者は、インスタンスを生成するたびに名前を (const char * 文字列として) 
与えてやる必要があります。ただ、回路クラスの実装者は、Name 引数につい
て何かを行う必要はありません。Circuit コンストラクタに Name 引数を転送
してやる必要もありません。このあたりの事情は SystemC と同じです。

回路のコンストラクタの CombOut(X, calcX) に注目してください。CombOut() 
は #define マクロで、この場合は X(*this, &NandGate::calcX) と展開され
ます。要するに、*this と &NandGate::calcX を引数として X 出力ポートイ
ンスタンスを生成しているわけです。こうすると、X 出力ポートインスタンス
は、シミュレーション最中に「お前の現在値は何か？」と問われた時に 
this->calcX() をコールバックしてくれます。よって、回路実装者としては、
calcX() を適切に記述することにより、NAND ゲートやら NOR ゲートやらの回
路を定義することができるわけです。

# CombOutPort<T> ポートに対する計算ルーチンのプロトタイプ宣言は
#    T ルーチン名() const;
# であるものとします。visibility は何でもかまいませんが、
# たいていは private にするのが自然でしょう。

calcX() の定義では、入力ポート A,B の現在値を A(), B() という形で調べ
てから NAND 演算した結果をリターンしました。operator overloading に抵抗が
あるなら A.get(), B.get() という形を使ってもかまいません。

入力ポートにせよ出力ポートにせよ、「現在値」はポートのベースクラスによっ
て自動的にキャッシングされます。calcX() としては、「2 回目以降の呼び出
され時に直ちに答えを返せるよう、キャッシングしよう」と気を利かせる必要
はありません (ベースクラスがキャッシングの面倒を見てくれるから、同一サ
イクルで calcX() が 2 回呼び出されること自体があり得ない)。また、
calcX() 内で A() や B() を複数回呼び出した場合、2 回目以降はキャッシュ
の値が直ちに返ってきます (そうはいっても、自前でローカル変数キャッシン
グするのに比べたら仮想関数呼び出しオーバヘッド分だけ遅いので、calcX() 
内で A,B ポートの現在値を何度も使うのならローカル変数に保持するのがよ
い)。

# ベースクラスのキャッシュの値は、シミュレーションクロックサイクルが
# 進むたびに自動的に invalidate されます。

説明が長くなってしまいましたが、要するに、「入力ポートと出力ポートを宣
言して、出力ポートの計算ルーチンをバインドして、計算ルーチンを定義」よ
うな感じで NAND ゲート回路クラスを書くことができた、ということです。組
み合わせ論理回路では、evaluate,update フェーズのことを気にする必要はあ
りません。evaluate,update はベースクラスのデフォルト処理 (NOP) になり
ます。

[B.1.2] テストジグクラスを作る
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
ATPG 風に、サイクルごとにランダムな値を NAND ゲートに入れてやることに
して、NAND ゲートの出力が正当かどうかをベリファイします。

        +------------+         +-------------+
        |            |-------->|             |
        |            |-------->|             |
        | テストジグ |         | NAND ゲート |
        |            |<--------|             |
        |            |         |             |
        +------------+         +-------------+

    class TestJig : public CycleC::Circuit {
    public:
      InPort<bool>          X;
      VarOutPort<bool>      A, B;
      unsigned int          m_rng;
      TestJig(Name name) : m_rng(0x10130945) {}
    protected:
      virtual void evaluate_self() {
        bool expect = !(A() && B());
        bool actual = X();
        if (actual != expect) throw std::runtime_error("verify error");
      }
      virtual void update_self() {
        m_rng = m_rng * 1103515245 + 12345;
        A = (m_rng >> 13) & 1;
        B = (m_rng >> 23) & 1;
      }
    };

NAND ゲートとは入出力ポートが逆で、「A,B を出力して X を入力し、ベリファ
イを行う」回路になります。A,B は「変数出力ポート VarOutPort<bool>」と
して作りました。VarOutPort<T> は内部に T 型の変数を持ち、その値を現在
値として出力するので、インスタンス生成時にいちいち「ポート出力値計算ルー
チン」をバインドする必要がありません。その分記述が楽です。

# A,B の現在値は A(),B() または A.get(),B.get() で得ることができます。
# 値の変更は A = ...; や A.set(...); で行えます。A = ...; という記述を
# みると「出力ポート」というより「変数そのもの」に見えますが、現在値を
# 得るのにいちいち A() と書く必要があるので、変数そのものではないこと
# がバレています。実際、代入構文のほうも、operator=() しかオーバーロー
# ド定義してないので、+= や &= 等は使えません。

テストジグは順序論理回路で、evaluate,update フェーズの処理を意識する必
要があります。evaluate,update フェーズの処理は evaluate_self(),
update_self() という仮想手続きとして定義します。evaluate(),update() と
いう名前のほうが自然なのですが、その名前の手続きは「evaluate_self() or
update_self() と全サブ回路の evaluate() or update() を順不同で呼ぶ」動
作としてベースクラスで固定的に定義されており、各回路クラスでカスタマイ
ズするのは evaluate_self(),update_self() になります。

テストジグの内部ステートは m_rng という乱数生成ワークです。幸か不幸か
乱数生成計算は入力信号に依存しないので、更新準備を evaluate フェーズで
「入力信号を調べながら」行う必要はありません。更新準備と更新を update 
フェーズで一挙に行うことにしました。

# A,B ポート内蔵変数もテストジグ内部ステートといえるかもしれません。
# m_rng の bit13, bit23 に対応するよう、update_self() で代入しました。
# ただし、インスタンス生成時 (シミュレーション先頭サイクル) に A,B を
# 「m_rng の bit13, bit23 に対応するようセット」しておらず、イイカゲン
# です (今の m_rng 初期値はたまたま bit13,bit23 が 0 なので、大丈夫だ
# けど)。

evaluate フェーズでは、入力信号を調べてベリファイを行うようにしました。
ベリファイは「内部ステートの更新」ではありませんが、入力信号を調べる必
要があるので、update フェーズではなく evaluate フェーズで行うべき処理
といえます。

[B.1.3] テストベンチクラスを作る
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
NAND ゲートとテストジグを組み合わせてテストベンチとします。

    class TestBench : public CycleC::Circuit {
    public:
      TestBench(Name name) : m_nand("nand"), m_jig("jig") {
        m_nand.A.src() = m_jig.A;
        m_nand.B.src() = m_jig.B;
        m_jig.X.src() = m_nand.X;
      }
    private:
      NandGate      m_nand;
      TestJig       m_jig;
    };

テストベンチは、NAND ゲートとテストジグのインスタンスを 1 つずつ
持つ階層設計回路になります。

階層設計回路は、コンストラクタの作り方に注意が必要です。

まず、階層設計回路のコンストラクタは、サブ回路インスタンスを 1 つずつ、
名前を付けて明示的に生成してやる必要があります。面倒ですが、SystemC
と同じ方針なのでしかたありません。

次に、階層設計回路のコンストラクタは、コンストラクタ本体において、サブ
回路どうしを接続してやる必要があります。記述のしかたは、「NAND ゲート
の入力ポート A の発信源はテストジグの出力ポート A である」という感覚で
m_nand.A.src() = m_jig.A; と書きます。この構文は proxy クラスや 
operator overloading を駆使しており、好みが分かれるかもしれません。同
じことを愚直に書くなら m_nand.A.connect(m_jig.A); となります。

[B.1.4] シミュレーションメインルーチンを書く
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
テストベンチのインスタンスを作って 100 サイクルシミュレーションします。

    #include <iostream>

    int main() {
      int the_cycle = -1;
      try {
        static TestBench tb("tb");
        std::cout << "Simulation start" << std::endl;
        for (the_cycle=0; the_cycle<100; ++the_cycle) {
          tb.tick();
        }
        std::cout << "Simulation end" << std::endl;
        return 0;
      } catch (std::exception& e) {
        std::cout << std::flush;
        std::cerr << "\nFatal Error at cycle " << the_cycle << ": "
                  << e.what() << "." << std::endl;
        return 2;
      } catch (...) {
        std::cout << std::flush;
        std::cerr << "\nCurious exception occurred." << std::endl;
        return 2;
      }
    }

テストベンチのインスタンスは static 宣言して「ハードウェアは静的オブジェ
クト」という意識を出してみました。static 宣言せずにローカルオブジェク
トとしてスタック上に生成しても理論的には問題ありませんが、現実には大規
模回路のときにスタック不足エラーになる恐れがあります。

tick() を呼ぶと、全サブ回路の evaluate() が順不同で呼ばれてから全サブ
回路の update() が順不同で呼ばれます。つまり、テストベンチ全体が 1 サ
イクル進みます。シミュレーションメインルーチンとしては、満足するまで
tick() を繰り返し呼べば OK です。

このプログラムをコンパイルして実行すると、
    Simulation start
    Simulation end
と表示されます。verify error 例外が起こらなかったのでシミュレーション
成功、ということです。

[B.1.5] 信号を覗き見する
^^^^^^^^^^^^^^^^^^^^^^^^
不幸にして verify error 例外が起こった場合、あるいは「例外は起こらなかっ
たけど本当に意図通りにランダムシミュレーションしているのか確認したい」
場合、信号を覗き見してチェックする必要があります。

覗き見したい回路がシミュレーションメインルーチンからアクセス可能なら、
その回路の public な入出力ポートを自由に覗き見できます。本サンプルの場
合、TestBench クラスの m_nand, m_jig メンバ変数を public にしたうえで、
シミュレーションメインルーチンの for ループを次のように書けば OK です。

        for (the_cycle=0; the_cycle<100; ++the_cycle) {
          std::cout << "cycle " << the_cycle
                    << ": jig.out " << tb.m_jig.A()
                    << " " << tb.m_jig.B()
                    << " -> nand.in " << tb.m_nand.A()
                    << " " << tb.m_nand.B()
                    << " -> nand.out " << tb.m_nand.X()
                    << " -> jig.in " << tb.m_jig.X()
                    << "\n";
          tb.tick();
        }

これで再コンパイルして実行すると

    Simulation start
    cycle 0: jig.out 0 0 -> nand.in 0 0 -> nand.out 1 -> jig.in 1
    cycle 1: jig.out 1 0 -> nand.in 1 0 -> nand.out 1 -> jig.in 1
    cycle 2: jig.out 1 1 -> nand.in 1 1 -> nand.out 0 -> jig.in 0
    cycle 3: jig.out 1 1 -> nand.in 1 1 -> nand.out 0 -> jig.in 0
    cycle 4: jig.out 1 1 -> nand.in 1 1 -> nand.out 0 -> jig.in 0
    cycle 5: jig.out 1 0 -> nand.in 1 0 -> nand.out 1 -> jig.in 1
    cycle 6: jig.out 0 0 -> nand.in 0 0 -> nand.out 1 -> jig.in 1
    cycle 7: jig.out 1 0 -> nand.in 1 0 -> nand.out 1 -> jig.in 1
    cycle 8: jig.out 0 0 -> nand.in 0 0 -> nand.out 1 -> jig.in 1
    cycle 9: jig.out 1 0 -> nand.in 1 0 -> nand.out 1 -> jig.in 1
    cycle 10: jig.out 0 1 -> nand.in 0 1 -> nand.out 1 -> jig.in 1
    cycle 11: jig.out 1 0 -> nand.in 1 0 -> nand.out 1 -> jig.in 1
    cycle 12: jig.out 1 1 -> nand.in 1 1 -> nand.out 0 -> jig.in 0
    cycle 13: jig.out 1 1 -> nand.in 1 1 -> nand.out 0 -> jig.in 0
    cycle 14: jig.out 0 1 -> nand.in 0 1 -> nand.out 1 -> jig.in 1
    cycle 15: jig.out 1 0 -> nand.in 1 0 -> nand.out 1 -> jig.in 1
       …中略…
    Simulation end

と表示されるので、意図通りにランダムシミュレーションしていることがわか
ります。

----------------------------------
[B.2] カウンターのシミュレーション
----------------------------------

順序論理回路の例として 4bit カウンタを設計してシミュレーションしてみ
ます。3 種類のコードを作ります。
    ゲートと FF を組み合わせて階層設計の構造記述をするバージョン
    synthesizable な Register Transfer レベルの記述をするバージョン
    ビヘイビアモデルのような記述をするバージョン

[B.2.1] 構造記述バージョンを作る
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
ゲートを組み合わせてインクリメンタを作り、インクリメンタと FF を
組み合わせてカウンタを作る、という 2 階層の構造記述をしてみます。

まず、AND,XOR ゲート回路クラスを作ります。

    #include "cyclec.h"

    class AndGate : public CycleC::Circuit {
      HAS_COMBOUTPORT(AndGate);
    public:
      InPort<bool>          A, B;
      CombOutPort<bool>     X;
      AndGate(Name name) : CombOut(X, calcX) {}
    private:
      bool calcX() const { return A() && B(); }
    };

    class XorGate : public CycleC::Circuit {
      HAS_COMBOUTPORT(XorGate);
    public:
      InPort<bool>          A, B;
      CombOutPort<bool>     X;
      XorGate(Name name) : CombOut(X, calcX) {}
    private:
      bool calcX() const { return A() ^ B(); }
    };

次に 4bit インクリメンターの回路クラスを作ります。

    class Incrementer4 : public CycleC::Circuit {
      HAS_COMBOUTPORT(Incrementer4);
    public:
      InPort<bool>       A0,A1,A2,A3;
      CombOutPort<bool>  Y0;
      FwdOutPort<bool>   Y1,Y2,Y3;
      Incrementer4(Name name)
        : CombOut(Y0,calc_Y0), m_and1("and1"), m_and2("and2"),
          m_xor1("xor1"), m_xor2("xor1"), m_xor3("xor1") {
        // Y1 = A0^A1
        // Y2 = (A0&A1)^A2
        // Y3 = (A0&A1&A2)^A3
	Y1.src() = m_xor1.X;
	m_xor1.A.src() = A0;
	m_xor1.B.src() = A1;
	Y2.src() = m_xor2.X;
	m_xor2.A.src() = m_and1.X;
	m_xor2.B.src() = A2;
	m_and1.A.src() = A0;
	m_and1.B.src() = A1;
	Y3.src() = m_xor3.X;
	m_xor3.A.src() = m_and2.X;
	m_xor3.B.src() = A3;
	m_and2.A.src() = m_and1.X;
	m_and2.B.src() = A2;
      }
    private:
      AndGate   m_and1, m_and2;
      XorGate   m_xor1, m_xor2, m_xor3;
      bool calc_Y0() const { return !A0(); }
    };

サブ回路インスタンスをメンバ変数として持って、コンストラクタで名前を指
定して接続指定する、という階層設計回路記述の大枠は [B.1.3] 節のテスト
ベンチクラスと同じ造りです。ただ、テストベンチクラスが 0 入力 0 出力だっ
たのに対して、インクリメンタには入出力ポートがあるので、そのあたりが違っ
ています。

階層設計回路の入力ポートは、NandGate 等のフラット回路の入力ポートと同
じように InPort<T> として宣言します。その入力ポートは、サブ回路入力ポー
トの信号発信源として使うことができます。

階層設計回路の出力ポートは、たいていは「forwarding 出力ポート 
FwdOutPort<T>」として宣言します。コンストラクタ本体で「この forwarding 
出力ポートの信号発信源はこのサブ回路のこの出力ポートだ」という感じで接
続を指定してやれば、シミュレーション時に、そのサブ回路の出力値がそのま
ま転送されます。階層設計回路を完全に構造記述すれば、出力ポートは全て 
FwdOutPort<T> になるはずです。

しかし、階層設計回路といっても、「サブ回路の出力をちょっと加工して出力
する」みたいなグルーロジックまで完全に構造記述するのは面倒だ、というケー
スも多々あります。そういうケースでは CombOutPort<T> を使ってかまいませ
ん。今回のインクリメンタでは、「Y0 出力は A0 入力の反転」というのをわ
ざわざ NOT ゲートインスタンス使って構造記述するのが面倒なので、そこだ
け CombOutPort<bool> にして calc_Y0() ルーチンで計算させました。

インクリメンタの利用者側は、出力ポートが CombOutPort<T> だろうが 
FwdOutPort<T> だろうが気にしないはずです。利用者が出力ポートに対して行
いたいのは「値を調べる」「別の InPort or FwdOutPort の信号発生源として
利用する」程度であり、言い換えれば、利用者は、全ての出力ポートを
OutPort<T> (CombOutPort,FwdOutPort 共通のベースクラス) として扱うだけ
で事足りるはずです。

# クラス宣言の字面が CombOutPort,FwdOutPort になっているのは利用者にとっ
# ては「実装の詳細が不必要に露呈していて見晴らしが悪い」のですが、いわ
# ゆる pimpl idiom を使わない限り、しかたありません。

# A0〜A3 は 4 要素配列として宣言してもかまいません。Y0〜Y3 は
# 型が異なるのでそのままでは 4 要素配列にできませんが、
#     public:  FwdOutPort<bool>  Y[4];
#     private: CombOutPort<bool> Y0;
#     in constructor-body: Y[0].src() = Y0;
# とすれば、出力ポートを Y[0]〜Y[3] という感じに配列化できます。

次に、フリップフロップの回路クラスを作ります。

    class FlipFlop : public CycleC::Circuit {
    public:
      InPort<bool>       D;
      VarOutPort<bool>   Q;
      FlipFlop(Name name) {}
    protected:
      virtual void evaluate_self() { m_nextQ = D(); }
      virtual void update_self() { Q = m_nextQ; }
    private:
      bool m_nextQ;
    };

    あるいは、

    class FlipFlop : public CycleC::Circuit {
    public:
      InPort<bool>       D;
      RegOutPort<bool>   Q;
      FlipFlop(Name name) {}
    protected:
      virtual void evaluate_self() { Q.nxt() = D(); }
    };

もともと、CycleC では、フリップフロップ(レジスタ)をいちいち構造記述す
る必要がないように、Register<T> や RegOutPort<T> などのクラスを提供し
ています。なので、わざわざフリップフロップクラスを作るのはかなり違和感
があります。あくまで「CycleC 説明用の非実用的サンプル」と思ってくださ
い。

VarOutPort を使ったフリップフロップは、「evaluate フェーズで内部状態更
新の準備をし、update フェーズで実際更新を行う」という方針を端的にコー
ディングしています。一方、RegOutPort を使ったフリップフロップは、
evaluate_self() しか定義していません。RegOutPort は、内部に「現在値」
「次値」という 2 つのワークを持ち、update フェーズで自動的に更新作業を
行います。なので、RegOutPort を使って回路を実装するときは evaluate フェー
ズで次値を設定するだけで事足ります (m_nextQ を別枠で確保する必要もない)。

さて、やっと目的の 4bit カウンター回路クラスを作ります。フリップフロッ
プとインクリメンターを組み合わせて接続します。

    class Counter4Structure : public CycleC::Circuit {
    public:
      FwdOutPort<bool>  Y0,Y1,Y2,Y3;
      Counter4Structure(Name name)
        : m_ff0("ff0"), m_ff1("ff1"), m_ff2("ff2"), m_ff3("ff3"),
          m_inc("inc") {
        Y0.src() = m_ff0.Q;
        Y1.src() = m_ff1.Q;
        Y2.src() = m_ff2.Q;
        Y3.src() = m_ff3.Q;
        m_ff0.D.src() = m_inc.Y0;
        m_ff1.D.src() = m_inc.Y1;
        m_ff2.D.src() = m_inc.Y2;
        m_ff3.D.src() = m_inc.Y3;
        m_inc.A0.src() = m_ff0.Q;
        m_inc.A1.src() = m_ff1.Q;
        m_inc.A2.src() = m_ff2.Q;
        m_inc.A3.src() = m_ff3.Q;
      }
    private:
      FlipFlop      m_ff0, m_ff1, m_ff2, m_ff3;
      Incrementer4  m_inc;
    };

階層設計回路クラスの記述としては Incrementer4 と同じ原理であり、目新し
い点はありません。

m_ff0 〜 m_ff3 を配列として宣言したい、と思うかもしれませんが、生成時
に名前を指定する必要があるので、配列として宣言することができません。ど
うしても配列として生成したいなら、wrapper クラスを作って名前を自動生成
する引数無しコンストラクタを作る、というような小細工が必要です。不満で
はありますが、天下の SystemC でも事情は同じであり、CycleC だけの欠陥で
はありません。

[B.2.2] RTL 記述バージョンを作る
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
RTL 記述バージョンは、4bit カウンタを、階層無しで、レジスタの更新方法を
式で記述します。

    class Counter4RTL : public CycleC::Circuit {
    public:
      RegOutPort<bool>   Y0,Y1,Y2,Y3;
      Counter4RTL(Name name) {}
    protected:
      virtual void evaluate_self() {
        unsigned int n = (Y3()<<3) | (Y2()<<2) | (Y1()<<1) | Y0();
        unsigned int n1 = (n + 1) & 15;
        Y0.nxt() = n1 & 1;
        Y1.nxt() = (n1 >> 1) & 1;
        Y2.nxt() = (n1 >> 2) & 1;
        Y3.nxt() = n1 >> 3;
      }
    };

さきほど FlipFlop クラスで RegOutPort<T> の使い方のとおり、「evaluate 
フェーズで次値を設定する」という記述スタイルです。この記述スタイルは、
Verilog,VHDL 等の synthesizable RTL と同じ抽象度といえます。

[B.2.3] ビヘイビア記述バージョンを作る
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
ビヘイビア記述バージョンは、レジスタを設けずに変数で記述します。

    class Counter4Behavior : public CycleC::Circuit {
    public:
      VarOutPort<bool>  Y0,Y1,Y2,Y3;
      Counter4Behavior(Name name) : m_cnt(0) {}
    protected:
      virtual void update_self() {
        m_cnt = (m_cnt + 1) & 15;
        Y0 = m_cnt & 1;
        Y1 = (m_cnt >> 1) & 1;
        Y2 = (m_cnt >> 2) & 1;
        Y3 = m_cnt >> 3;
      }
    private:
      unsigned int  m_cnt;
    };

このカウンタの例では、RTL 記述より若干タイプ量を減らすことができました。
しかし、CycleC のシミュレーション枠組自体がクロックサイクルを意識して
いるため、SystemC の transaction level のような高い抽象度のビヘイビア
記述はできません。せいぜい、「レジスタの現在値・次値」を意識する RTL 
作法から外れて変数を直接いじることができる程度です。しかも、変数を直接
いじる場合でもクロックサイクルを忘れるわけにはいかないので、結局「変数
の現在値・次値」という感じになって RTL 記述よりタイプ量が増えてしまう
ケースもままあります (e.g. FlipFlop クラス)。そうはいっても、[B.1.2] 
節の TestJig クラスのように、ビヘイビア記述が有効なケースもあるにはあ
るので、適材適所で使い分けるのがいいでしょう。

[B.2.4] テストベンチクラスを作る
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
3 つのカウンタを並列実行して同じ出力を出すかどうかベリファイする、とい
うテストベンチクラスを作ります。

基本に則れば「テストパターンと期待値を生成してベリファイするテストジグ」
クラスと「カウンタとテストジグのインスタンスをつなぐだけのテストベンチ」
クラス、という造りにすべきところです。しかし、カウンタには入力がないの
でテストパターン生成は不要ですし、期待値生成は Counter4Behavior が行っ
てくれる (Counter4Behavior をバグ無しリファレンスデザインとみなす) の
で、残るベリファイ処理のためだけにわざわざテストジグクラスを設けるまで
もない、と判断しました。

    class TestBench : public CycleC::Circuit {
    public:
      TestBench(Name name)
        : m_cnts("cnts"), m_cntr("cntr"), m_cntb("cntb") {}
    protected:
      virtual void evaluate_self() {
        bool s0 = m_cnts.Y0();
        bool s1 = m_cnts.Y1();
        bool s2 = m_cnts.Y2();
        bool s3 = m_cnts.Y3();
        bool r0 = m_cntr.Y0();
        bool r1 = m_cntr.Y1();
        bool r2 = m_cntr.Y2();
        bool r3 = m_cntr.Y3();
        bool b0 = m_cntb.Y0();
        bool b1 = m_cntb.Y1();
        bool b2 = m_cntb.Y2();
        bool b3 = m_cntb.Y3();
        if (! (s0 == b0 && r0 == b0
               && s1 == b1 && r1 == b1
               && s2 == b2 && r2 == b2
               && s3 == b3 && r3 == b3)) {
          throw std::runtime_error("verify error");
        }
      }
    private:
      Counter4Structure m_cnts;
      Counter4RTL       m_cntr;
      Counter4Behavior  m_cntb;
    };

[B.2.5] シミュレーションメインルーチンを書く
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
シミュレーションメインルーチンは [B.1.4] 節と同じです。

プログラムをコンパイルして実行すると、例によって
    Simulation start
    Simulation end
と無愛想に表示され、verify error 例外が起こらなかったのでシミュレーショ
ン成功ということがわかります。

[B.2.6] 信号を覗き見する
^^^^^^^^^^^^^^^^^^^^^^^^
いくら verify error 例外が起こらなかったといっても、やっぱり信号をモニ
ターしないと安心できないので、TestBench の m_cnts,m_cntr,m_cntb を public
にして、シミュレーションメインルーチンの for ループを

        for (the_cycle=0; the_cycle<100; ++the_cycle) {
          std::cout << "cycle " << the_cycle
                    << ": cnts="
                    << tb.m_cnts.Y3()
                    << tb.m_cnts.Y2()
                    << tb.m_cnts.Y1()
                    << tb.m_cnts.Y0()
                    << " cntr="
                    << tb.m_cntr.Y3()
                    << tb.m_cntr.Y2()
                    << tb.m_cntr.Y1()
                    << tb.m_cntr.Y0()
                    << " cntb="
                    << tb.m_cntb.Y3()
                    << tb.m_cntb.Y2()
                    << tb.m_cntb.Y1()
                    << tb.m_cntb.Y0()
                    << "\n";
          tb.tick();
        }

と変えます。これで再コンパイルして実行すると

    Simulation start
    cycle 0: cnts=0000 cntr=0000 cntb=0000
    cycle 1: cnts=0001 cntr=0001 cntb=0001
    cycle 2: cnts=0010 cntr=0010 cntb=0010
    cycle 3: cnts=0011 cntr=0011 cntb=0011
    cycle 4: cnts=0100 cntr=0100 cntb=0100
    cycle 5: cnts=0101 cntr=0101 cntb=0101
    cycle 6: cnts=0110 cntr=0110 cntb=0110
    cycle 7: cnts=0111 cntr=0111 cntb=0111
    cycle 8: cnts=1000 cntr=1000 cntb=1000
    cycle 9: cnts=1001 cntr=1001 cntb=1001
    cycle 10: cnts=1010 cntr=1010 cntb=1010
    cycle 11: cnts=1011 cntr=1011 cntb=1011
    cycle 12: cnts=1100 cntr=1100 cntb=1100
    cycle 13: cnts=1101 cntr=1101 cntb=1101
    cycle 14: cnts=1110 cntr=1110 cntb=1110
    cycle 15: cnts=1111 cntr=1111 cntb=1111
    cycle 16: cnts=0000 cntr=0000 cntb=0000
    cycle 17: cnts=0001 cntr=0001 cntb=0001
    cycle 18: cnts=0010 cntr=0010 cntb=0010
    cycle 19: cnts=0011 cntr=0011 cntb=0011
       …中略…
    Simulation end

と表示されるので、カウンターが意図通りに動いていることがわかります。


==============================
[C] 回路利用者向けリファレンス
==============================

「回路利用者」とは、シミュレーションを行うメインルーチンを書こうとする
プログラマー、を指します。

---------------------
[C.1] CycleC::Port<T>
---------------------

T 型の入出力ポートの抽象ベースクラスです。Port<T> から派生した具体ポー
トのインスタンスが、具体回路クラスにメンバ変数として所属します。

具体ポートには以下のタイプがあり、具体回路クラスのヘッダファイルでは
ポートが以下の名前で宣言されているはずです。

   InPort<T>         入力ポート
   CombOutPort<T>    組み合わせ論理タイプの出力ポート
   RegOutPort<T>     レジスタ内蔵の出力ポート
   RegRefOutPort<T>  他所のレジスタを参照して出力するポート
   FwdOutPort<T>     サブ回路の出力信号を forward 出力するポート
   VarOutPort<T>     変数内蔵の出力ポート (ビヘイビアレベル記述用)
   VarRefOutPort<T>  他所の変数を参照して出力するポート (同上)

しかし、シミュレーションメインルーチン担当者がこれら種々の具体ポート型
を使い分ける必要はありません。テスト対象回路の各ポートについて、入力か
出力かぐらいは気持ちとして区別するかもしれませんが、プログラムとして区
別する必要はないはずです。組み合わせ出力なのかレジスタ出力かなんてのは、
気持ちとしてもプログラムとしても区別する必要はないはずです。とにかく
「T 型のポート」として扱えば事足りるでしょう。

[C.1.1] T get() const
^^^^^^^^^^^^^^^^^^^^^
ポートの現在値を返します。シミュレーション時に信号を覗き見するために利
用してください。

糖衣構文として、
    someport.get()
の代わりに
    someport()
とも書けるようにしてあります (要するに operator() を定義してある)。

各シミュレーションサイクルごとの最初の呼び出し時には、ポートの接続関係
をたどったり組み合わせ論理計算を行ったりするためにそれなりに時間がかか
るかもしれませんが、2 回目以降の呼び出し時には、キャッシュしておいた値
をすぐに返します。そうはいっても、仮想関数呼び出しオーバヘッドは消せな
いので、無駄な呼び出しを避けるに越したことはありません。

この手続きは、具体回路クラスの性質しだいで例外を投げる可能性があります。
あるいは、T のコピーコンストラクタや代入オペレータがいかがわしい造りに
なっていれば、例外を投げる可能性があります。

# CycleC ライブラリとしては明示的に例外を投げることはありません。
# 具体回路クラスとしても、ほとんどはものは例外を投げないでしょう。

----------------------------------
[C.2] CycleC::Circuit::Register<T>
----------------------------------

T 型のレジスタ(フリップフロップ)です。具体回路クラスにメンバ変数として
所属します。

# ただし、レジスタがそのまま具体回路の出力ポートとして使われる場合は、
# Register<T> でなく RegOutPort<T> という出力ポートとして具体回路クラ
# スに所属するのが普通です。したがって、Register<T> は、たいていは「外
# 界との接続に使われない内部レジスタ」を意味するでしょう。

[C.2.1] T cur() const
^^^^^^^^^^^^^^^^^^^^^
レジスタの現在値を返します。シミュレーション時に信号を覗き見するために
利用してください。

レジスタにおいては「現在値」「次値」の区別が重要ですから、敢えて get() 
という名前を避けました。しかも、回路利用者には「現在値を読む」ことしか
許さないので、API は cur() だけです。

糖衣構文はありません。いちいち somereg.cur() とタイプして、「現在値」
ということを意識してください。

この手続きは、内部ワークの値を返すだけなので、普通なら例外を投げること
はありません。ただ、T のコピーコンストラクタや代入オペレータがいかがわ
しい造りになっていると、…以下略。

---------------------
[C.3] CycleC::Circuit
---------------------

全ての回路に共通する性質をまとめた、抽象ベースクラスです。SystemC の 
sc_module に相当します。全ての具体回路クラスは Circuit から派生します。

シミュレーションメインルーチン担当者が直接扱うのは、テストベンチを表す
具体回路クラスになります。テストベンチクラスは、テスト対象回路やテスト
ジグ回路 (いずれも具体回路クラス) のインスタンスをメンバ変数として持ち
ますから、シミュレーションメインルーチン担当者は、テスト対象回路クラス
やテストジグクラスを間接的に扱うことになるでしょう。

[C.3.1] 公開メンバ変数
^^^^^^^^^^^^^^^^^^^^^^
Circuit クラス自体は、公開メンバ変数を持ちません。

具体回路クラスは、一般に、「サブ回路のインスタンス」や「入出力ポートの
インスタンス」等をメンバ変数として持ち得ます。前者は Circuit から派生
した具体回路クラスのインスタンス、後者は Port<T> から派生した具体ポー
トクラスのインスタンスです。

テストベンチクラスは、普通は 0 入力 0 出力なので、入出力ポートは持たな
いでしょう。代わりに、サブ回路として、テスト対象回路やテストジグ回路や 
ATPG 回路を持つでしょう。

テスト対象回路等は、ほぼ間違いなく入出力ポートを持つでしょう。テスト対
象回路が複雑なものだったら、サブ回路を持つことも十分あり得るでしょう。

[C.3.2] std::string name() const
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
回路の名前を返します。具体回路クラスのインスタンス名を回路階層に沿って
ドットで区切って並べた文字列になります。

# シミュレーションメインルーチンを愚直に書くならば、シミュレーションメ
# インルーチンが回路の名前を知らないことはあり得ないので、わざわざこの
# 手続きを使うまでもないでしょう。シミュレーション用のユーティリティサ
# ブルーチンとして「回路ポインタをもらって信号状態をベリファイする」よ
# うなのを作る場合は、エラーメッセージ表示のときにこの手続きが役立つで
# しょう。

具体回路のインスタンス名は、具体回路インスタンス生成時にユーザーがひと
つひとつ指定するようになっているはずです。具体回路の仕様書のコンストラ
クタの欄をごらんください。

この手続きは、std::bad_alloc 等の std::string 系の例外を投げるおそれが
あります。

[C.3.3] void evaluate(), void update(), void tick()
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
evaluate() は、CycleC シミュレーションの evaluate フェーズの処理を行い
ます。すなわち、クロックサイクル中の動作に対応する処理を行います。自身
の evaluate フェーズ処理をするだけでなく、全てのサブ回路についても順不
同に evaluate() を呼び出します。

update() は、CycleC シミュレーションの update フェーズの処理を行います。
すなわち、クロックサイクル切り替わり時の動作に対応する処理を行います。
自身の update フェーズ処理をするだけでなく、全てのサブ回路についても順
不同に update() を呼び出します。

tick() は、evaluate() してから update() します。すなわち、シミュレーショ
ンを 1 サイクルぶん進めます。

シミュレーションメインルーチン作成者は、たいていは tick() を使うだけで
事足りるでしょう。

[C.3.4] void reset()
^^^^^^^^^^^^^^^^^^^^
回路をリセットします。自身のリセット処理をするだけでなく、全てのサブ回路
についても順不同に reset() を呼び出します。

ただ、具体回路クラスの中には、「自身のリセット処理」の実装をサボってい
るものがあるかもしれません。[B.2] 節のカウンター回路も、リセット処理の
実装をサボっています。そういう手抜き実装の回路クラスに対して reset() 
を呼び出してもエラーや例外にはなりませんが、所望のリセット動作が行われ
ないおそれがあります。

# Register<T> や Port<T> は、具体回路クラスがとくにリセット処理を定義
# しなくても、reset() 呼び出し時に自動的にリセットされます。なので 
# [B.2] 節の例でいえば Counter4Structure と Counter4RTL はリセットが効
# きます。しかし、Counter4Behavior は、m_cnt メンバをリセットする処理
# がどこにも書かれていないので、リセットが効きません。

この手続きは、具体回路クラス (およびそれが保有するサブ回路のクラス) の
「自身のリセット処理」しだいで例外を投げる可能性があります。といっても、
現実問題としては、ほとんどの具体回路クラスは例外を投げないでしょう。

======================================
[D] 階層無し回路実装者向けリファレンス
======================================

階層構造を持たないフラットな回路を実装するプログラマーのためのリファレ
ンスです。

--------------------------------
[D.1] CycleC::Circuit::InPort<T>
--------------------------------

T 型の入力ポートです。

具体回路クラスの public メンバ変数として、InPort<bool> なり 
InPort<double> なり InPort<MyStruct> なり、好きな型のポートのインスタ
ンスを宣言してください。

# 入力ポートは、他の回路に接続してもらってナンボ、ですから、protected 
# や private にするのは無意味です。

CycleC ライブラリとしては、T が POD (plain old data) であることを想定
していますが、POD でなくても、コピー生成や代入や参照やポインタ処理が 
POD と同じセマンティクスで出来さえすれば、問題ないでしょう。

[D.1.1] InPort()
^^^^^^^^^^^^^^^^
コンストラクタです。引数はありません。

内部的には、所属する具体回路クラスとの関連付けを行うために SystemC 風
のトリッキーな処理をしています。…が、具体回路実装者がそのことを意識す
る必要はありません。

SystemC とのアナロジーを考えると、コンストラクタ引数に「インスタンス名
文字列」があるべきでは？ と思うかもしれませんが、それを厳密に行うと具
体回路を実装するのが面倒になるので、ポートには名前を付けられないことに
しました。はてさて、「デバッグが難しすぎる！ やっぱりポートにも名前を
付けられるようにしよう」と改版することになるのかどうか…。

# じつは CycleC ライブラリ自体には既にポートインスタンス名の概念が存在
# し、name() 手続きも存在します。ただ、インスタンス名として決め打ちで 
# RTTI 型名を使うので、複数のインスタンスを区別できません。

この手続きは、std::bad_alloc 例外を投げる可能性があります。

[D.1.2] T get() const
^^^^^^^^^^^^^^^^^^^^^
ポートの現在値を返します。[C.1.1] 節参照。

具体回路クラスの組み合わせ論理を実装するために利用してください。

実装としては、信号発生源ポートの get() を呼び出します。

# 自ポートと信号発生源ポートとの接続は、親回路が面倒を見てくれるので、
# 階層無しフラット回路実装者としては知る必要はありません。

この手続きが例外を投げるかどうかは信号発生源ポートの get() しだい
ですが、たいていは、例外を投げることはないでしょう。

-------------------------------------
[D.2] CycleC::Circuit::CombOutPort<T>
-------------------------------------

T 型の組み合わせ論理出力ポートです。

具体回路クラスのメンバ変数として、CombOutPort<bool> なり 
CombOutPort<double> なり CombOutPort<MyStruct> なり、好きな型のポート
のインスタンスを宣言してください。

利用者に見せたいポートなら public メンバ変数にすればいいし、実装者だけ
が使いたい中間信号のポートなら private メンバ変数にすればいいでしょう。

CycleC ライブラリとしては、T が POD (plain old data) であることを想定
していますが、POD でなくても、コピー生成や代入や参照やポインタ処理が 
POD と同じセマンティクスで出来さえすれば、問題ないでしょう。

[D.2.1] HAS_COMBOUTPORT(circuit)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
所属する具体回路クラスが組み合わせ論理出力ポートを持つことを宣言するプ
リプロセッサマクロです。[B.1.1] 節の例のように、具体回路クラス宣言内の
先頭におまじないとして置いてください。

circuit 引数には、所属する具体回路クラス名を指定してください。

このようなおまじないが必要なのは、組み合わせ論理出力ポートだけです。な
んともカッコ悪いですが、CycleC を (専用言語処理系でなく) C++ ライブラ
リとして実装するために、この小細工が必要になりました。SystemC の
SC_HAS_PROCESS() マクロと同様の事情です。

[D.2.2] CombOut(port, func)
^^^^^^^^^^^^^^^^^^^^^^^^^^^
CombOutPort<T> のコンストラクタを呼び出すためのプリプロセッサマクロです。
具体回路クラスのコンストラクタのメンバ初期化リスト内に置いてください。

port はポート名、func は「そのポートの値を計算する (具体回路クラスの)
メンバ関数」で、
    T func() const;
という宣言になっているようにしてください。

このプリプロセッサマクロの実装は、
    #define CombOut(port, func)    port(*this, func)
となっており、CombOutPort<T> のコンストラクタに *this (所属する具体回
路のインスタンス…への参照) と func を渡すことになります。コンストラク
タは *this への参照と func を内部にメモします。

組み合わせ論理出力ポートのインスタンスそれぞれに、「ポートの値を計算す
るルーチン」を登録する必要があるので、具体回路クラスのコンストラクタの
メンバ初期化リストに、忘れずに CombOut() を置いてください。まぁ、忘れ
たらコンパイルエラーになるのですぐ気がつきます。

CombOutPort<T> のコンストラクタは、std::bad_alloc 例外を投げる可能性が
あります。

[D.2.3] T get() const
^^^^^^^^^^^^^^^^^^^^^
ポートの現在値を返します。[C.1.1] 節参照。

本来この手続きは回路利用者向けですが、回路実装者が使ってもかまいません。
とくに、中間信号のポート (private メンバ変数) の場合は、回路実装者が
get() を使うことになります。

実装としては、CombOut() マクロで登録された「ポートの値を計算するルーチ
ン (所属する具体回路クラスのメンバ関数)」を呼び出します。

この手続きが例外を投げるかどうかは「ポートの値を計算するルーチン」しだ
いですが、たいていは、例外を投げることはないでしょう。

-----------------
[D.3] Register<T>
-----------------

T 型のレジスタ (フリップフロップ) です。内部に現在値と次値のワークを
持ち、いわゆるノンブロッキング代入をサポートします。

具体回路クラスのメンバ変数として、Register<bool> なり Register<double> 
なり Register<MyStruct> なり、好きな型のレジスタのインスタンスを宣言し
てください。

利用者に見せたいレジスタなら public メンバ変数にすればいいし、実装者だ
けが使いたい中間信号のレジスタなら private メンバ変数にすればいいでしょ
う。ただ、「利用者に見せたい」というのが「registered output port とし
て扱いたい (i.e., 他の回路の入力ポートに接続してもらいたい)」というこ
とであれば、Register<T> だと機能不足です。そういう場合は [D.4] 節の 
RegOutPort<T> を使ってください。

CycleC ライブラリとしては、T が POD (plain old data) であることを想定
していますが、POD でなくても、コピー生成や代入や参照やポインタ処理が 
POD と同じセマンティクスで出来さえすれば、問題ないでしょう。

[D.3.1] Register(const T& initial_value = T())
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
コンストラクタです。引数はレジスタの初期値です。引数を省略すると、初期
値は「T の自然なデフォルト値 (Plain Old Data なら全ビット 0)」になりま
す。

「初期値」は、「インスタンス生成時に現在値ワークにセットされる値」であ
ると同時に、「シミュレーションメインルーチンが reset() を呼び出したと
きにレジスタの現在値ワークにセットされる値」でもあります。そのため、レ
ジスタのインスタンスは、現在値ワークと次値ワークの他に初期値ワークも持
ち、initial_value を後生大事に記憶します。

# 初期値ワークは参照でなく実体であり、コンストラクタは initial_value 
# を初期値ワークにコピーします。したがって、initial_value が短命のテン
# ポラリオブジェクトであっても問題ありません。

この手続きは、std::bad_alloc 例外を投げる可能性があります。また、T の
コピーコンストラクタや代入オペレータがいかがわしい造りになっていると、
…以下略。

[D.3.2] T cur() const
^^^^^^^^^^^^^^^^^^^^^
レジスタの現在値を返します。[C.2.1] 節参照。

[D.3.3] void nxt(const T& next_value)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
レジスタの次値を設定します。具体回路クラスの evaluate_self() 手続き
から呼んでください。

同じレジスタインスタンスに対して何回呼んでもかまいませんが、最後に設定
した次値だけが有効です。

あるレジスタインスタンスに対して 1 回も呼ばないと、次値＝現在値となり、
クロックが進んでもレジスタの値は変化しません。

# 「クロックが進むときにレジスタの値を変化させる (次値ワークの値を現在
# 値ワークにコピーする)」動作は Register<T> クラスが自動的に面倒を見ま
# す。Register<T> 利用者が明示的に何かをする必要はありません。

この手続きは、内部ワークに next_value をコピーします。したがって、
next_value が短命のテンポラリオブジェクトであっても問題ありません。

糖衣構文として、
   somereg.nxt(...);
の代わりに
   somereg.nxt() = ...;
とも書けるようにしてあります。

次値は write only です。過去に設定した値を読み出すことはできません。

この手続きは、内部ワークに値を代入するだけなので、普通なら例外を投げる
ことはありません。ただ、T のコピーコンストラクタや代入オペレータがいか
がわしい造りになっていると、…以下略。

[D.3.4] void cke(bool cke_value)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
レジスタの CKE (clock enable) の値を設定します。具体回路クラスの
evaluate_self() 手続きから呼んでください。

同じレジスタインスタンスに対して何回呼んでもかまいませんが、最後に設定
した値だけが有効です。

あるレジスタインスタンスに対して 1 回も呼ばないと、CKE 値＝true となり、
クロックが進んだときにレジスタの値が更新されます。

糖衣構文として、
   somereg.cke(...);
の代わりに
   somereg.cke() = ...;
とも書けるようにしてあります。

CKE 値は write only です。過去に設定した値を読み出すことはできません。

この手続きは、内部ワークに値を代入するだけなので、例外を投げることは
ありません。

-------------------
[D.4] RegOutPort<T>
-------------------

T 型のレジスタ兼出力ポートです。

具体回路クラスのメンバ変数として、RegOutPort<bool> なり 
RegOutPort<double> なり RegOutPort<MyStruct> なり、好きな型のレジスタ
出力ポートのインスタンスを宣言してください。

利用者に見せたいレジスタ出力ポートなら public メンバ変数にすればいいし、
実装者だけが使いたい中間信号のレジスタ出力ポートなら private メンバ変
数にすればいいでしょう。

CycleC ライブラリとしては、T が POD (plain old data) であることを想定
していますが、POD でなくても、コピー生成や代入や参照やポインタ処理が 
POD と同じセマンティクスで出来さえすれば、問題ないでしょう。

[D.4.1] RegOutPort(const T& initial_value = T())
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
コンストラクタです。引数はレジスタの初期値で、[D.3.1] 節のレジスタコン
ストラクタと同じように扱われます。

この手続きは、std::bad_alloc 例外を投げる可能性があります。また、T の
コピーコンストラクタや代入オペレータがいかがわしい造りになっていると、
…以下略。

[D.4.2] T get() const
^^^^^^^^^^^^^^^^^^^^^
ポートの現在値 (＝レジスタの現在値) を返します。[C.1.1] 節参照。

本来この手続きは回路利用者向けですが、回路実装者が使ってもかまいません。
とくに、中間信号のポート (private メンバ変数) の場合は、回路実装者が
get() を使うことになります。

この手続きは、各クロックサイクルの 1 回目の呼び出しであっても、レジス
タ現在値ワークの値を返すだけなので、大して時間はかかりません。

この手続きは、内部ワークの値を返すだけなので、普通なら例外を投げること
はありません。ただ、T のコピーコンストラクタや代入オペレータがいかがわ
しい造りになっていると、…以下略。

[D.4.3] T cur() const
^^^^^^^^^^^^^^^^^^^^^
レジスタの現在値 (＝ポートの現在値) を返します。[C.2.1] 節参照。

RegOutPort<T> において get() と cur() は事実上同じ動作になります。

[D.4.4] void nxt(const T& next_value),  void cke(boolcke_value)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
レジスタの次値や CKE 値を設定します。[D.3.3],[D.3.4] 節参照。

----------------------
[D.5] RegRefOutPort<T>
----------------------

T 型のレジスタを参照するポートです。RegOutPort<T> が「Register<T> イン
スタンスを内蔵し、その値を出力するポート」であるのに対し、
RegRefOutPort<T> は「他所の Register<T> インスタンスを参照して、その値
を出力するポート」です。

具体回路クラスの public メンバ変数として、RegRefOutPort<bool> なり 
RegRefOutPort<double> なり RegRefOutPort<MyStruct> なり、好きな型のレ
ジスタ参照出力ポートのインスタンスを宣言してください。

# 他所のレジスタインスタンスをわざわざ出力ポート化したい理由といえば
# 「他の回路インスタンスにつなげてもらうため」以外にあり得ないので、
# protected や private にするのは無意味でしょう。

CycleC ライブラリとしては、T が POD (plain old data) であることを想定
していますが、POD でなくても、コピー生成や代入や参照やポインタ処理が 
POD と同じセマンティクスで出来さえすれば、問題ないでしょう。

[D.5.1] RegRefOut(port, ref)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^
RegRefOutPort<T> のコンストラクタを呼び出すためのプリプロセッサマクロです。
具体回路クラスのコンストラクタのメンバ初期化リスト内に置いてください。

port はポート名、ref は「そのポートが参照する Register<T> インスタンス」
です。

このプリプロセッサマクロの実装は、
    #define RegRefOut(port, ref)    port(ref)
となっており、RegRefOutPort<T> のコンストラクタに ref を渡すだけです。
わざわざプリプロセッサマクロ化するまでもないような気もしますが、このマ
クロを使えば、組み合わせ論理出力ポートの CombOut() マクロと見た目を揃
えることができます。

レジスタ参照出力ポートのインスタンスそれぞれに、「参照すべきレジスタ」
を登録する必要があるので、具体回路クラスのコンストラクタのメンバ初期化
リストに、忘れずに RegRefOut() を置いてください。まぁ、忘れたらコンパイ
ルエラーになるのですぐ気がつきます。

RegRefOutPort<T> のコンストラクタは、std::bad_alloc 例外を投げる可能性
があります。

[D.5.2] T get() const
^^^^^^^^^^^^^^^^^^^^^
ポートの現在値 (＝参照レジスタの現在値) を返します。[C.1.1] 節参照。

本来この手続きは回路利用者向けですが、回路実装者が使ってもかまいません。

この手続きは、各クロックサイクルの 1 回目の呼び出しであっても、参照レ
ジスタ現在値ワークの値を返すだけなので、大して時間はかかりません。

この手続きは、参照レジスタの cur() 手続きを呼び出すだけなので、普通な
ら例外を投げることはありません。ただ、T のコピーコンストラクタや代入オ
ペレータがいかがわしい造りになっていると、…以下略。

-------------------
[D.6] VarOutPort<T>
-------------------

T 型の変数兼出力ポートです。回路を synthesizable RTL スタイルで記述す
るなら組み合わせ論理とレジスタだけを使うべきですが、ビヘイビアスタイル
でいいのなら変数を使うことにより楽に記述できるケースがあります。

具体回路クラスのメンバ変数として、VarOutPort<bool> なり 
VarOutPort<double> なり VarOutPort<MyStruct> なり、好きな型の変数出力
ポートのインスタンスを宣言してください。

利用者に見せたい変数出力ポートなら public メンバ変数にすればいいし、実
装者だけが使いたい中間変数の出力ポートなら private メンバ変数にすれば
いいでしょう。

CycleC ライブラリとしては、T が POD (plain old data) であることを想定
していますが、POD でなくても、コピー生成や代入や参照やポインタ処理が 
POD と同じセマンティクスで出来さえすれば、問題ないでしょう。

[D.6.1] VarOutPort(const T& initial_value = T())
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
コンストラクタです。引数は変数の初期値です。引数を省略すると、初期値は
「T の自然なデフォルト値 (Plain Old Data なら全ビット 0)」になります。

「初期値」は、「インスタンス生成時に変数値ワークにセットされる値」であ
ると同時に、「シミュレーションメインルーチンが reset() を呼び出したと
きに変数値ワークにセットされる値」でもあります。そのため、
VarOutPort<T> のインスタンスは、変数値ワークの他に初期値ワークも持ち、
initial_value を後生大事に記憶します。

# 初期値ワークは参照でなく実体であり、コンストラクタは initial_value 
# を初期値ワークにコピーします。したがって、initial_value が短命のテン
# ポラリオブジェクトであっても問題ありません。

この手続きは、std::bad_alloc 例外を投げる可能性があります。また、T の
コピーコンストラクタや代入オペレータがいかがわしい造りになっていると、
…以下略。

[D.6.2] T get() const
^^^^^^^^^^^^^^^^^^^^^
ポートの現在値 (＝変数の値) を返します。[C.1.1] 節参照。

本来この手続きは回路利用者向けですが、回路実装者が使ってもかまいません。
とくに、中間信号のポート (private メンバ変数) の場合は、回路実装者が
get() を使うことになります。

この手続きは、各クロックサイクルの 1 回目の呼び出しであっても、内部ワー
クの値を返すだけなので、大して時間はかかりません。

この手続きは、内部ワークの値を返すだけなので、普通なら例外を投げること
はありません。ただ、T のコピーコンストラクタや代入オペレータがいかがわ
しい造りになっていると、…以下略。

[D.6.3] void set(const T& value)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
ポートが保持する変数に値をセットします。CycleC シミュレーション原理に

糖衣構文として、
    someport.set(value)
の代わりに
    someport = value
とも書けるようにしてあります (要するに operator= を定義してある)。
ただし
    someport += value
みたいなのは書けません。

ポートが保持する変数は T 型の実体オブジェクトであり、本手続きは value 
をコピー代入します。したがって、value が短命テンポラリオブジェクトであっ
てもかまいません。

この手続きは、内部ワークに値を代入するだけなので、普通なら例外を投げる
ことはありません。ただ、T のコピーコンストラクタや代入オペレータがいか
がわしい造りになっていると、…以下略。

------------------
[D.7] VarRefOut<T>
------------------

T 型の変数を参照するポートです。VarOutPort<T> が「T 型の変数インスタン
スを内蔵し、その値を出力するポート」であるのに対し、VarRefOutPort<T> 
は「他所の変数インスタンスを参照して、その値を出力するポート」です。

具体回路クラスの public メンバ変数として、VarRefOutPort<bool> なり 
VarRefOutPort<double> なり VarRefOutPort<MyStruct> なり、好きな型の変
数参照出力ポートのインスタンスを宣言してください。

# 他所の変数をわざわざ出力ポート化したい理由といえば「他の回路インスタ
# ンスにつなげてもらうため」以外にあり得ないので、protected や private 
# にするのは無意味でしょう。

CycleC ライブラリとしては、T が POD (plain old data) であることを想定
していますが、POD でなくても、コピー生成や代入や参照やポインタ処理が 
POD と同じセマンティクスで出来さえすれば、問題ないでしょう。

[D.7.1] VarRefOut(port, ref)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^
VarRefOutPort<T> のコンストラクタを呼び出すためのプリプロセッサマクロ
です。具体回路クラスのコンストラクタのメンバ初期化リスト内に置いてくだ
さい。

port はポート名、ref は「そのポートが参照する T 型変数インスタンス」
です。

このプリプロセッサマクロの実装は、
    #define VarRefOut(port, ref)    port(ref)
となっており、VarRefOutPort<T> のコンストラクタに ref を渡すだけです。
わざわざプリプロセッサマクロ化するまでもないような気もしますが、このマ
クロを使えば、組み合わせ論理出力ポートの CombOut() マクロと見た目を揃
えることができます。

変数参照出力ポートのインスタンスそれぞれに、「参照すべき変数」を登録す
る必要があるので、具体回路クラスのコンストラクタのメンバ初期化リストに、
忘れずに VarRefOut() を置いてください。まぁ、忘れたらコンパイルエラー
になるのですぐ気がつきます。

VarRefOutPort<T> のコンストラクタは、std::bad_alloc 例外を投げる可能性
があります。

[D.7.2] T get() const
^^^^^^^^^^^^^^^^^^^^^
ポートの現在値 (＝参照変数の現在値) を返します。[C.1.1] 節参照。

本来この手続きは回路利用者向けですが、回路実装者が使ってもかまいません。

この手続きは、各クロックサイクルの 1 回目の呼び出しであっても、参照変
数ワークの値を返すだけなので、大して時間はかかりません。

この手続きは、参照変数の値を返すだけなので、普通なら例外を投げることは
ありません。ただ、T のコピーコンストラクタや代入オペレータがいかがわし
い造りになっていると、…以下略。

---------------------
[D.8] CycleC::Circuit
---------------------

全ての回路に共通する性質をまとめた、抽象ベースクラスです。SystemC の 
sc_module に相当します。全ての具体回路クラスは Circuit から派生します。

[D.8.1] 公開メンバ変数
^^^^^^^^^^^^^^^^^^^^^^
Circuit クラス自体は、公開メンバ変数を持ちません。

階層無しフラット回路の具体回路クラスは、[D.1]〜[D.7] で説明したような
入出力ポートやレジスタのインスタンスをメンバ変数として持ちます。ビヘイ
ビアレベルの記述なら、int 等の普通の変数をメンバ変数として持つこともあ
り得ます。

[D.8.2] Circuit()
^^^^^^^^^^^^^^^^^
コンストラクタです。引数はありませんので、具体回路クラスコンストラクタ
のメンバ初期化リストにいちいちリストアップする必要はありません。

ただし、実際には Circuit コンストラクタには「インスタンス名」という
隠れた引数が存在します。その隠れ引数は SystemC 由来のテクニックで
コンストラクタに渡されます ([D.8.3] 節)。

この手続きは std::bad_alloc 例外を投げる可能性があります。

[D.8.3] CycleC::Circuit::Name
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
回路のインスタンス名を Circuit コンストラクタに隠れ引数として渡すため
のヘルパークラスです。具体回路クラスは、以下のお作法に従ってください。

・具体回路クラスのコンストラクタは、CycleC::Circuit::Name 型の引数を
  値渡しで受け取る。受け取った引数に対して何か処理を行う必要はないし
  行ってはならない。
・具体回路クラスの利用者は、回路インスタンス生成時にインスタンス名を
  C 文字列として指定する。具体回路クラス利用者は CycleC::Circuit::
  Name 型を直接には扱わないものとする。C 文字列は短命であってもよい
  (回路インスタンス生成完了後に解体してもよい)。

このお作法に従うと、回路インスタンス生成時に CycleC::Circuit::Name 型
の型変換コンストラクタ (C 文字列 → Name 型) が呼び出されて Name 型の
テンポラリオブジェクトが生まれ、回路インスタンス生成完了時にそのテンポ
ラリオブジェクトが解体されるはずです。この、Name のコンストラクタとデ
ストラクタが、Cicruit コンストラクタへの隠れ引数を渡す面倒を見る仕掛け
になっています。

Name のコンストラクタは std::bad_alloc 例外を投げる可能性があります。

[D.8.4] std::string name() const
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
回路の名前を返します。具体回路クラスのインスタンス名を回路階層に沿って
ドットで区切って並べた文字列になります。

この手続きは、std::bad_alloc 等の std::string 系の例外を投げるおそれが
あります。

[D.8.5] void evaluate_self(), void update_self()
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
CycleC シミュレーションの evaluate, update フェーズの処理を行う 
protected 仮想手続きです。具体回路クラス実装者は、必要に応じて、これら
の手続きを適切に定義してください。

回路利用者にとっては CycleC シミュレーションは evaluate(), update() 手
続きです ([C.3.3] 節) が、回路実装者にとっては CycleC シミュレーション
は evaluate_self(), update_self() 手続きになります。evaluate(),
update() 手続きは、それぞれ evaluate_self(), update_self() を呼ぶと同
時に、全回路共通の処理 (保持するレジスタやポートのメンテナンス) を行い
ます。したがって、evaluate_self(), update_self() には、その具体回路に
特有の処理だけを書けば OK です。

具体回路クラスが組み合わせ論理回路の場合、原理的に、evaluate_self(),
update_self() を定義する必要はありません。

具体回路クラスがレジスタとロジックを組み合わせた synthesizable RTL ス
タイルの順序論理回路の場合、evaluate_self() で全レジスタの次値を設定す
る必要があります。update_self() を定義する必要はありません。

具体回路クラスが普通の変数や VarOutPort<T> をメンバ変数として持つビヘ
イビア記述スタイルの順序論理回路の場合、evaluate_self() と 
update_self() を適切に定義する必要があります。

[D.8.6] void reset_self()
^^^^^^^^^^^^^^^^^^^^^^^^^
リセット処理を行う protected 仮想手続きです。具体回路クラス実装者は、
必要に応じて、この手続きを適切に定義してください。

回路利用者にとってはリセット処理は reset() 手続きです ([C.3.4] 節) が、
回路実装者にとってはリセット処理は reset_self() 手続きになります。
reset() 手続きは、reset_self() を呼んでから、全回路共通の処理(保持する
レジスタやポートのメンテナンス) を行います。したがって、reset_self() 
には、その具体回路に特有の処理だけを書けば OK です。

具体回路クラスが組み合わせ論理回路の場合、原理的に、reset_self() を
定義する必要はありません。

具体回路クラスがレジスタとロジックを組み合わせた synthesizable RTL ス
タイルの順序論理回路の場合、原理的に、reset_self() を定義する必要はあ
りません。

具体回路クラスが普通の変数や VarOutPort<T> をメンバ変数として持つビヘ
イビア記述スタイルの順序論理回路の場合、reset_self() を適切に定義する
必要があります。

==================================
[E] 階層回路実装者向けリファレンス
==================================

階層構造を持つ回路 (のルートノードや中間ノード) を実装するプログラマー
のためのリファレンスです。[D] 節の全てに加えて、以下の違いを意識する必
要があります。

--------------------------------
[E.1] CycleC::Circuit::InPort<T>
--------------------------------

T 型の入力ポートです。[D.1] 節の全ての仕様に加え、以下の API を意識する
必要があります。

[E.1.1] void connect(const Port<T>& src)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
ポートの信号発生源を設定します。

階層回路のコンストラクタは、全てのサブ回路の全ての入力ポートを、この手
続きを使って何らかの信号発生源に接続してください。信号発生源としては
以下の種類が考えられます。
  (1) どこかのサブ回路の出力ポート
  (2) 階層回路自身の入力ポート
  (3) 階層回路自身の出力ポート

階層回路が、「自らは何も演算を行わず、サブ回路どうしやサブ回路と自身の
ポートを接続するだけ」であれば、信号発生源は (1) か (2) になるでしょう。
一方、「階層回路自身の入力信号を少し加工してからサブ回路に入れてやる」
ような回路の場合は、その加工した信号を階層回路自身の private 出力ポー
トとして宣言し、(3) のパターンを使うことになるでしょう。

糖衣構文として、
    someport.connect(srcport)
の代わりに
    someport.src() = srcport
とも書けるようにしてあります。

この手続きは、内部ワークにポインタを代入するだけなので、例外を投げるこ
とはありません。

-------------------
[E.2] FwdOutPort<T>
-------------------

T 型の転送出力ポートです。サブ回路の出力をそのまま階層回路自身の出力ポー
トに転送したいとき、このポートを使うと楽に書けます。

具体階層回路クラスの public メンバ変数として、FwdOutPort<bool> なり 
FwdOutPort<double> なり FwdOutPort<MyStruct> なり、好きな型の転送出力
ポートのインスタンスを宣言してください。

# サブ回路の出力信号をわざわざ転送出力ポート化したい理由といえば
# 「親回路や兄弟回路につなげてもらうため」以外にあり得ないので、
# protected や private にするのは無意味でしょう。

CycleC ライブラリとしては、T が POD (plain old data) であることを想定
していますが、POD でなくても、コピー生成や代入や参照やポインタ処理が 
POD と同じセマンティクスで出来さえすれば、問題ないでしょう。

[E.2.1] FwdOutPort()
^^^^^^^^^^^^^^^^^^^^
コンストラクタです。引数はありません。

この手続きは、std::bad_alloc 例外を投げる可能性があります。また、T の
コピーコンストラクタや代入オペレータがいかがわしい造りになっていると、
…以下略。

[E.2.2] void connect(const Port<T>& src)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
ポートの信号発生源を設定します。[E.1.1] 節と同様に使ってください。

[E.2.3] T get() const
^^^^^^^^^^^^^^^^^^^^^
ポートの現在値 (＝信号発生源ポートの現在値) を返します。[C.1.1] 節参照。

この手続きは回路利用者向けです。回路実装者が使ってもかまいませんが、回
路実装者は信号発生源サブ回路の出力ポートを直接見ればいいので、わざわざ
転送出力ポートの get() 手続きを使わなければならない理由はありません。

この手続きが例外を投げるかどうかは信号発生源ポートの get() しだい
ですが、たいていは、例外を投げることはないでしょう。

---------------------
[E.3] CycleC::Circuit
---------------------

全ての回路に共通する性質をまとめた、抽象ベースクラスです。階層無しフラッ
ト回路 ([D.8] 節) のときと同じ要領で使えます。API 説明は以下の点で微妙
に異なりますが、些細な事項にすぎません。

・公開メンバ関数

  階層回路の具体回路クラスは、[D.8.1] 節で説明したような入出力ポート／
  レジスタ／変数のインスタンスだけでなく、サブ回路のインスタンスをメ
  ンバ変数として持ちます。

  サブ回路インスタンスには、生成時に名前を指定してやる必要があるはず
  です。すなわち、階層回路コンストラクタのメンバ初期化リストに、
  サブ回路インスタンス変数名とインスタンス名をずらりと並べることに
  なるはずです。

・evaluate_self(), update_self(), reset_self()

  それぞれ、「自分の分」だけ定義すれば OK です。
  サブ回路の分は evaluate(),update(),reset() が自動的に面倒を
  見てくれます。


============================
[F] 発展技：多相クロック対応
============================

CycleC ライブラリは、単相クロックシミュレーションをメインターゲットと
していますが、多相クロックシミュレーションもできます。

# 無節操にクロックドメインを混在させた任意の回路をシミュレーションでき
# るわけではありませんが、「クロックドメインをまたがる信号は、送信側も
# 受信側も FF でたたいてしかも 1 対 1 接続する」というお行儀のよい多相
# クロック回路なら OK です。

-------------------------------------------------------
[F.1] CycleC における多相クロックシミュレーションの概要
-------------------------------------------------------

CycleC シミュレーションはゼロ遅延モデルであり、FF のセットアップタイム・
ホールドタイム・アウトプットディレイが全てゼロ、組み合わせロジックのプ
ロパゲーションディレイも全てゼロ、という理想シミュレーションになります。
ゼロ遅延モデル自体は単相クロック限定ではないので、多相クロックにも矛盾
なく適用できます。ただし、ゼロ遅延で単相クロックの場合は時間をクロック
サイクル単位で数えれば事足りるのに対し、多相クロックの場合は、
nanosecond なり picosecond なりの単位で数える必要があります。

単相クロックのシミュレーションメインルーチン：

    /* 100 サイクル分シミュレートする */
    for (the_cycle=0; the_cycle<100; ++the_cycle) {
      tb.tick();
    }

多相クロックのシミュレーションメインルーチンのコンセプト：

    /* 1000 nanosecond 分シミュレートする */
    for (the_time=0; the_time<1000; ++the_time) {
      if (いずれかのクロックの立ち上がりエッジに該当する) {
        tb.tick(立ち上がったクロックのリスト);
      }
    }

このコンセプトを、具体的には以下のように実現します。

  (1) テストベンチ設計者は、システムで使うクロックに通し番号を
      割り振る (0〜31)。
  (2) テストベンチ設計者は、初期化時、各サブ回路インスタンスに、
      各自が使うべきクロックの番号を通知する。
  (3) 各サブ回路インスタンスは、通知されたクロック番号を再帰的に
      (取捨選択して) 孫回路等にも転送する。こうすることにより、
      全ての回路インスタンスが、シミュレーション開始前に、自分が
      従うべきクロック番号を把握できる。
  (4) シミュレーションメインルーチンは、各瞬間にどのクロックが
      立ち上がっているかをグローバル変数に設定して tb.tick() を
      呼ぶ。各回路インスタンスは、自分が従うべきクロックの立ち
      上がり時のみ、「順不同 evaluate、順不同 update」処理を行う。

      # "グローバル変数" というのは概念上の話で、実装上は
      # 「CycleC::Circuit クラスの public なクラス変数」。

----------------------------------------
[F.2] 多相クロック回路シミュレーション例
----------------------------------------

[F.2.1] 多相クロック回路クラスを作る
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
多相クロック回路モジュールの一般形として、

  (1) クロックドメイン 1 の単相クロックパーツ
  (2) クロックドメイン 2 の単相クロックパーツ
  (3) 2 つのパーツをつなぐグルーロジック

から成る階層回路を考えます。これの作り方さえ分かれば、任意の多相クロッ
ク回路を作れるはずです。具体例として、

  (1) Gray code カウンタ
  (2) Gray-to-binary 変換回路
  (3) synchronizer FF
      [クロックドメイン 1 で 1 回たたいた後、
       クロックドメイン 2 で 2 回たたく]

を考えます。

    #include "cyclec.h"
    #ifndef CYCLEC_MULTICLOCK
    #error "CYCLEC_MULTICLOCK not defined"
    #endif

    typedef unsigned char uchar;

    class GrayCodeCounter : public CycleC::Circuit {
      HAS_COMBOUTPORT(GrayCodeCounter);
    public:
      InPort<bool>        countenable;
      CombOutPort<uchar>  out;
      GrayCodeCounter(Name name) : CombOut(out, calc_out) {}
    private:
      Register<uchar>     m_count;
      uchar calc_out() const {
        uchar cnt = m_count.cur();
        return cnt ^ (cnt>>1);
      }
    protected:
      virtual void evaluate_self() {
        m_count.nxt() = m_count.cur() + 1;
        m_count.cke() = countenable();
      }
    };

    class GrayToBinConverter : public CycleC::Circuit {
      HAS_COMBOUTPORT(GrayToBinConverter);
    public:
      InPort<uchar>       din;
      CombOutPort<uchar>  dout;
      GrayToBinConverter(Name name) : CombOut(dout, calc_dout) {}
    private:
      uchar calc_dout() const {
        uchar x = din();
        x ^= (x>>1);
        x ^= (x>>2);
        x ^= (x>>4);
        return x;
      }
    };

    class SampleDualClockCircuit : public CycleC::Circuit {
    public:
      InPort<bool>        countenable;   // domain 1
      FwdOutPort<uchar>   dout;          // domain 2
    private:
      GrayCodeCounter     graycounter;   // domain 1
      GrayToBinConverter  graytobin;     // domain 2
      Register<uchar>     m_ff0;         // domain 1
      Register<uchar>     m_ff1;         // domain 2
      RegOutPort<uchar>   m_ff2;         // domain 2
      clkmap_t            m_clk1map, m_clk2map;
    public:
      SampleDualClockCircuit(Name name)
        : graycounter("graycounter"), graytobin("graytobin") {
        graycounter.countenable.src() = countenable;
        graytobin.din.src() = m_ff2;
        dout.src() = graytobin.dout;
      }
      void assign_clocks(int clk1_id, int clk2_id) {
        m_clk1map = 1<<clk1_id;
        m_clk2map = 1<<clk2_id;
        m_clockmap = m_clk1map | m_clk2map;
        graycounter.assign_clock(clk1_id);
        graytobin.assign_clock(clk2_id);
      }
    protected:
      virtual void evaluate_self() {
        if ((the_active_clock_map & m_clk1map) != 0) {
          m_ff0.nxt() = graycounter.out();
        }
        if ((the_active_clock_map & m_clk2map) != 0) {
          m_ff1.nxt() = m_ff0.cur();
          m_ff2.nxt() = m_ff1.cur();
        }
      }
      virtual void update_self() {
        if ((the_active_clock_map & m_clk1map) != 0) {
          countenable.tick();
          m_ff0.tick();
        }
        if ((the_active_clock_map & m_clk2map) != 0) {
          m_ff1.tick();
          m_ff2.tick();
          dout.tick();
        }
      }
    };

まず目新しいのが CYCLEC_MULTICLOCK というプリプロセッサマクロです。こ
れは多相クロックシミュレーションをするためのおまじないです。多相クロッ
クシミュレーションをする場合、CYCLEC_MULTICLOCK を定義した状態で 
cyclec.h をコンパイルしなければなりません。Makefile の CFLAGS で
-DCYCLEC_MULTICLOCK オプションを指定するなり、いっそのこと cyclec.h
自体を書き換えて冒頭で #define CYCLEC_MULTICLOCK するなりしてください。

# 「大は小を兼ねる」ので、単相クロックシミュレーション時に
# CYCLEC_MULTICLOCK を定義してもかまいませんが、単相クロックシミュレー
# ションで事足りるのなら CYCLEC_MULTICLOCK を定義しないほうが高速かつ
# 省メモリになります。

# CYCLEC_MULTICLOCK の有り無しは、プログラム全体にわたって首尾一貫して
# いなければなりません。「プログラム全体」というのは cyclec.cc も含み
# ます。つまり、単相クロック用の cyclec.o と多相クロック用の cyclec.o 
# をきちんと使い分ける必要があります。同様に、単相クロックの回路 IP を
# 多相クロックシステムのパーツとして利用するときには、
# CYCLEC_MULTICLOCK を定義して再コンパイルする必要があります。

GrayCodeCounter と GrayToBinConverter は単相クロック回路で、目新しいと
ころはありません。

SampleDualClockCircuit は懸案の二相クロック回路で、いろいろと目新しい
点があります。

SampleDualClockCircuit のメンバ変数として、おなじみの入出力ポートや内
部サブ回路や内部レジスタのほかに、目新しい m_clk1map と m_clk2map とい
うのを宣言しています。これは、2 つのクロックの「システム内での通し番号」
を覚えておくためのものです。

2 つのクロックの「システム内での通し番号」は、親回路が assign_clocks() 
手続きを使って通知するものとします。clk1_id 引数は入力側クロックドメイ
ンのクロック番号、clk2_id 引数は出力側クロックドメインのクロック番号、
です。クロックの数や意味は回路ごとに異なるので、CycleC::Circuit クラス
自身は assign_clocks() 手続きに関知しません。各回路クラスが自主的に適
切な assign_clocks() 手続きを定義します。

SampleDualClockCircuit の assign_clocks() 手続きは、m_clk1map と 
m_clk2map にクロック番号 (のビットマップ) を記憶し、m_clockmap に「全
クロック分のビットマップ」を記憶し、サブ回路インスタンスにクロック番号
通知をしています。

m_clockmap は CycleC::Circuit クラス自身が定義しているメンバ変数で、
「回路が従うべき全クロック番号ぶんのビットマップ」を表すものとします。
CycleC::Circuit クラスは、evaluate() や update() の共通処理の際に
m_clockmap を参考にするので、具体回路クラス設計者が適切にこれを設定す
る必要があります。

サブ回路インスタンスへのクロック番号通知は、サブ回路が提供しているクロッ
ク通知手続きを使って行います。本例ではサブ回路は単相クロック回路なので、
CycleC::Circuit クラスが提供している assign_clock() 手続きを使って行い
ます。CycleC::Circuit::assign_clock() は、m_clockmap にクロック番号ビッ
トマップを設定して将来の evaluate(),update() に備えます。

# サブ回路も多相クロックの場合は、そのサブ回路クラスが独自に提供してい
# るはずの assign_clocks() 手続きを使って、クロック番号を通知します。

# assign_clock() 手続きを CycleC::Circuit クラスが提供しているため、多
# 相クロック回路クラスに対して assign_clocks() でなく assign_clock() 
# を呼ぶことが (構文的に) できてしまいますが、そういう呼び出しは無意味・
# 無効です。このへん、CycleC::Circuit クラスの設計が Liskov
# Substitution Principle に違反しており、行儀悪いです。…が、本マニュ
# アルの [A]〜[E] 節だけ見て作った単相クロック回路ソースコードをそのま
# ま多相クロックシステムの部品として使えるようにしたかったので、少々行
# 儀悪いのを承知でこのような設計にしました。

GrayToBinConverter は純粋組み合わせロジックなのでクロックは無関係、と
思うかもしれませんが、CycleC シミュレーション内部で「入出力ポートの現
在値をキャッシングしてクロックエッジでキャッシュクリア」という最適化を
行うので、たとえ純粋組み合わせロジックであっても所属クロックドメインを
意識して通知する必要があります。

SampleDualClockCircuit の evaluate_self(), update_self() は、
CycleC::Circuit::the_active_clock_map という public なクラス変数
(概念的にはグローバル変数) をチェックして、クロックドメイン 1,2 それぞ
れの出番のときだけそれぞれの処理を行います。とくに、update_self() にお
いて、「ポートやレジスタをどのクロックドメインに従って処理するか」を明
示的に書く必要があることに注意してください。単相クロック回路の場合はポー
トやレジスタの update 処理は CycleC::Circuit::update() 手続きが自動的
に面倒をみてくれますが、多相クロック回路の場合は「自動的に」というわけ
にいかないので、具体回路クラスの update_self() 手続きが明示的に処理し
なければいけません。処理し忘れてもコンパイルエラーにはならないのでやっ
かいです。

# ポートやレジスタには evaluate 処理がないので、update 処理を tick() 
# という名前のメンバ手続きで行う仕様になっています。そのため、
# update_self() が tick() を呼ぶ、というイレギュラーな見た目になります。
# まぁ、見方を変えれば、tick() されているオブジェクトは Circuit でなく 
# Port や Register であるということが一目でわかるので、便利だ、と言う
# こともできます。

本例では reset_self() を定義していませんが、CycleC の reset() は「パル
ス幅ゼロの非同期オールリセット」という意味なので、本例の場合はデフォル
トの「クロックドメインを気にせずポートとレジスタとサブ回路を全て再帰的
に reset() する」動作だけで十分です。

[F.2.2] ビヘイビア記述バージョンを作る
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
多相クロック回路のテストベクタと期待値を作るのは大変なので、ビヘイビア
記述バージョンを作ってバグ無しレファレンスデザイン扱いすることにします。

    class SampleDualClockBehaviorCircuit : public CycleC::Circuit {
      HAS_COMBOUTPORT(SampleDualClockBehaviorCircuit);
    public:
      InPort<bool>         countenable;
      CombOutPort<uchar>   dout;
      SampleDualClockBehaviorCircuit(Name name)
        : CombOut(dout, calc_dout) {
        m_clockmap = 0x3;
        reset_self();
      }
    private:
      bool                 m_enable;
      uchar                m_cnt, m_ff[3];
    protected:
      virtual void evaluate_self() {
        if ((the_active_clock_map & 1) != 0)  m_enable = countenable();
      }
      virtual void update_self() {
        if ((the_active_clock_map & 2) != 0) {
          m_ff[2] = m_ff[1];
          m_ff[1] = m_ff[0];
          dout.tick();
        }
        if ((the_active_clock_map & 1) != 0) {
          m_ff[0] = m_cnt;
          if (m_enable)  m_cnt ++;
          countenable.tick();
        }
      }
      virtual void reset_self() {
        m_enable = false;
        m_cnt = 0;
        m_ff[0] = 0;
        m_ff[1] = 0;
        m_ff[2] = 0;
      }
    private:
      uchar calc_dout() const { return m_ff[2]; }
    };

入力側クロック番号は 0、出力側クロック番号は 1、に決め打ちです。

[F.2.3] ATPG とテストベンチクラスを作る
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
ランダムなカウントイネーブル信号を生成する ATPG とテストベンチクラスを
作ります。ATPG は単なる「1bit 乱数発生器」なので、わざわざ独立クラスと
せずにテストベンチクラスに内蔵します。

    class TestBench : public CycleC::Circuit {
      SampleDualClockCircuit          dut;  /* device under test */
      SampleDualClockBehaviorCircuit  ref;  /* reference circuit */
      VarOutPort<bool>                countenable;
      unsigned int                    m_mseq;
    public:
      TestBench(Name name) : dut("dut"), ref("ref"),
                             countenable(false), m_mseq(0x10191836) {
        dut.countenable.src() = countenable;
        ref.countenable.src() = countenable;
        m_clockmap = 0x3;
        dut.assign_clocks(0, 1);
      }
    protected:
      virtual void evaluate_self() {
        if ((the_active_clock_map & 2) != 0) {
          uchar actual = dut.dout();
          uchar expect = ref.dout();
          if (actual != expect)  throw std::runtime_error("verify error");
        }
      }
      virtual void update_self() {
        if ((the_active_clock_map & 1) != 0) {
          // M-sequence polynomial = x^29 + x^2 + 1
          bool rnd = ((m_mseq >> 28) ^ (m_mseq >> 1)) & 1;
          m_mseq = (m_mseq << 1) | rnd;
          countenable = rnd;
          countenable.tick();
        }
      }
    };

入力側クロック番号は 0、出力側クロック番号は 1、に決め打ちです。

[F.2.4] シミュレーションメインルーチンを書く
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
入力側クロック 200MHz (5ns 周期)、出力側クロック 125MHz (8ns 周期)、と
いう条件で 3 millisecond 分のシミュレーションをしてみます。

    #include <iostream>

    int main() {
      int the_time = -1;
      try {
        static TestBench tb("tb");
        std::cout << "Simulation start" << std::endl;
        for (the_time=1; the_time<3000; ++the_time) {
          CycleC::Circuit::clkmap_t map = 0;
          if ((the_time % 5) == 0)  map |= (1<<0);
          if ((the_time % 8) == 0)  map |= (1<<1);
          if (map == 0)  continue;
          CycleC::Circuit::the_active_clock_map = map;
          tb.tick();
        }
        std::cout << "Simulation end" << std::endl;
        return 0;
      } catch (std::exception& e) {
        std::cout << std::flush;
        std::cerr << "\nFatal Error at time " << the_time << ": "
                  << e.what() << "." << std::endl;
        return 2;
      } catch (...) {
        std::cout << std::flush;
        std::cerr << "\nCurious exception occurred." << std::endl;
        return 2;
      }
    }

時刻を 1ns ずつインクリメントしながら、5 で割り切れるなら入力側クロッ
クの立ち上がりエッジ、8 で割り切れるなら出力側クロックの立ち上がりエッ
ジである、と判定して、いずれかの立ち上がりエッジのときだけ、
CycleC::Circuit::the_active_clock_map にクロック番号ビットマップを設定
してから tb.tick() を呼び出します。

for 文を the_time = 1 から始めていることに注目してください。時刻ゼロを
クロック立ち上がりエッジ扱いしたくないので、the_time = 1 から始めました。

このプログラムをコンパイルして実行すると、
    Simulation start
    Simulation end
と表示されます。verify error 例外が起こらなかったのでシミュレーション
成功、ということです。

# 注：
# [F.2.1]〜[F.2.4] 節のコードも CycleC ライブラリ自体 (cyclec.cc) も
# 全て、CYCLEC_MULTICLOCK マクロを定義してコンパイルする必要があります。

[F.2.5] 信号を覗き見する
^^^^^^^^^^^^^^^^^^^^^^^^
いくら verify error 例外が起こらなかったといっても、やっぱり信号をモニ
ターしないと安心できないので、TestBench の dut, ref 回路インスタンスを
public にして、SampleDualClockCircuit の graycounter, graytobin 回路イ
ンスタンスや m_ff0〜m_ff2 レジスタも public にして、シミュレーションメ
インルーチンの for ループを

        for (the_time=1; the_time<3000; ++the_time) {
          CycleC::Circuit::clkmap_t map = 0;
          if ((the_time % 5) == 0)  map |= (1<<0);
          if ((the_time % 8) == 0)  map |= (1<<1);
          if (map == 0)  continue;
          CycleC::Circuit::the_active_clock_map = map;
          tb.tick();
          std::cout << "time " << the_time
                    << ": " << tb.countenable()
                    << " " << (int)tb.dut.graycounter.out()
                    << ":" << (int)tb.dut.m_ff0.cur()
                    << ":" << (int)tb.dut.m_ff1.cur()
                    << ":" << (int)tb.dut.m_ff2.cur()
                    << " " << (int)tb.dut.dout()
                    << " " << (int)tb.ref.dout()
                    << "\n";
        }

と変えます。これで再コンパイルして実行すると

    Simulation start
    time 5: 0 0:0:0:0 0 0
    time 8: 0 0:0:0:0 0 0
    time 10: 0 0:0:0:0 0 0
    time 15: 0 0:0:0:0 0 0
    time 16: 0 0:0:0:0 0 0
    time 20: 0 0:0:0:0 0 0
    time 24: 0 0:0:0:0 0 0
    time 25: 0 0:0:0:0 0 0
    time 30: 0 0:0:0:0 0 0
    time 32: 0 0:0:0:0 0 0
    time 35: 0 0:0:0:0 0 0
    time 40: 0 0:0:0:0 0 0
    time 45: 1 0:0:0:0 0 0
    time 48: 1 0:0:0:0 0 0
    time 50: 1 1:0:0:0 0 0
    time 55: 1 3:1:0:0 0 0
    time 56: 1 3:1:1:0 0 0
    time 60: 1 2:3:1:0 0 0
    time 64: 1 2:3:3:1 1 1
    time 65: 0 6:2:3:1 1 1
    time 70: 1 6:6:3:1 1 1
    time 72: 1 6:6:6:3 2 2
    time 75: 0 7:6:6:3 2 2
    time 80: 1 7:7:6:6 4 4
    time 85: 1 5:7:6:6 4 4
    time 88: 1 5:7:7:6 4 4
    time 90: 0 4:5:7:6 4 4
    time 95: 1 4:4:7:6 4 4
    time 96: 1 4:4:4:7 5 5
    time 100: 0 12:4:4:7 5 5
    time 104: 0 12:4:4:4 7 7
       …中略…
    time 2985: 1 60:60:52:53 38 38
    time 2990: 1 61:60:52:53 38 38
    time 2992: 1 61:60:60:52 39 39
    time 2995: 1 63:61:60:52 39 39
    Simulation end

と表示されるので、意図通りに動いていることがわかります。

この表示コードは、「カウントアップした時刻が tick() するにふさわしい時
刻 (クロック立ち上がりエッジ) であるときに限り、tick() してから状態表
示する」という考え方になっています。なので、時刻ゼロの状態は表示されて
いません。

# 単相クロックの時は「現サイクルの状態を表示してから、次に進むために 
# tick() する」という考え方になっていたので、微妙に異なります。とはい
# え、異なってしまったのは the_time を for 文でカウントしたせいにすぎ
# ず、CycleC シミュレーションの理屈上の必然ではありません。

ちなみに、CycleC シミュレーションはゼロ遅延モデルですから、本例の背後
にある「カウンタ値を異なるクロックドメインの相手に渡すとき、不本意な結
果にならないようグレイコードで渡すと良い」という tips の「不本意な結果」
はシミュレートできません。8bit 値を uchar で一括渡ししているから不本意
な結果が生じないのではなく、たとえ 8bit 値を bool 信号 8 本で渡したと
しても、ゼロ遅延モデルである以上、不本意な結果は生じません。なので、こ
のグレイコード渡しのシミュレーションは「グレイコード渡しによって不本意
な結果を防げるかどうか」のシミュレーションにはならず、「グレイコード渡
しの RTL がグレイコード渡し回路として働いているか」のシミュレーション
になります。

[F.2.6] シミュレーションメインルーチンを楽に書く
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
シミュレーションメインルーチン (のクロック制御) を楽に書けるようにする
ため、CycleC ライブラリは CycleC::TimeKeeper というクラスを提供してい
ます。これを活用すれば、シミュレーションメインルーチンを以下のように
書けます。

    int main() {
      int the_time = -1;
      try {
        static TestBench tb("tb");
        static CycleC::TimeKeeper timekeeper;
        timekeeper.define_clock(0, 5);
        timekeeper.define_clock(1, 8);
        std::cout << "Simulation start" << std::endl;
        the_time = 0;
        do {
          std::cout << "time " << the_time
                    << ": " << timekeeper.cycle(0)
                    << " " << timekeeper.cycle(1)
                    << " " << tb.countenable()
                    << " " << (int)tb.dut.graycounter.out()
                    << ":" << (int)tb.dut.m_ff0.cur()
                    << ":" << (int)tb.dut.m_ff1.cur()
                    << ":" << (int)tb.dut.m_ff2.cur()
                    << " " << (int)tb.dut.dout()
                    << " " << (int)tb.ref.dout()
                    << "\n";
          timekeeper.advance();
          the_time = timekeeper.time();
          CycleC::Circuit::the_active_clock_map = timekeeper.clockmap();
          tb.tick();
        } while (the_time < 3000);
        std::cout << "Simulation end" << std::endl;
        return 0;
      } catch (std::exception& e) {
        std::cout << std::flush;
        std::cerr << "\nFatal Error at time " << the_time << ": "
                  << e.what() << "." << std::endl;
        return 2;
      } catch (...) {
        std::cout << std::flush;
        std::cerr << "\nCurious exception occurred." << std::endl;
        return 2;
      }
    }

TimeKeeper にクロック番号とクロック周期を登録すれば、advance() を呼ぶ
たびに「次に一番早く変化するクロックエッジ」を検索して時刻を進めてクロッ
ク番号ビットマップも作ってくれます。advance() してから time() を呼べば
その時刻を、clockmap() を呼べばその時刻で変化するクロック番号のビット
マップを得ることができます。さらに cycle() を呼べば、その時刻直後が各
クロックドメインにとって何サイクル目なのかを知ることもできます。

この表示コードは、単相クロックのときと同じく、「現状態を表示してから、
1 ステップ進めるために tick() する」という考え方になっています。なので、
以下のように、時刻ゼロの状態も表示されます。

    Simulation start
    time 0: 0 0 0 0:0:0:0 0 0
    time 5: 1 0 0 0:0:0:0 0 0
    time 8: 1 1 0 0:0:0:0 0 0
    time 10: 2 1 0 0:0:0:0 0 0
    time 15: 3 1 0 0:0:0:0 0 0
    time 16: 3 2 0 0:0:0:0 0 0
    time 20: 4 2 0 0:0:0:0 0 0
    time 24: 4 3 0 0:0:0:0 0 0
    time 25: 5 3 0 0:0:0:0 0 0
    time 30: 6 3 0 0:0:0:0 0 0
    time 32: 6 4 0 0:0:0:0 0 0
    time 35: 7 4 0 0:0:0:0 0 0
    time 40: 8 5 0 0:0:0:0 0 0
    time 45: 9 5 1 0:0:0:0 0 0
    time 48: 9 6 1 0:0:0:0 0 0
    time 50: 10 6 1 1:0:0:0 0 0
    time 55: 11 6 1 3:1:0:0 0 0
    time 56: 11 7 1 3:1:1:0 0 0
    time 60: 12 7 1 2:3:1:0 0 0
    time 64: 12 8 1 2:3:3:1 1 1
    time 65: 13 8 0 6:2:3:1 1 1
    time 70: 14 8 1 6:6:3:1 1 1
    time 72: 14 9 1 6:6:6:3 2 2
    time 75: 15 9 0 7:6:6:3 2 2
    time 80: 16 10 1 7:7:6:6 4 4
    time 85: 17 10 1 5:7:6:6 4 4
    time 88: 17 11 1 5:7:7:6 4 4
    time 90: 18 11 0 4:5:7:6 4 4
    time 95: 19 11 1 4:4:7:6 4 4
    time 96: 19 12 1 4:4:4:7 5 5
    time 100: 20 12 0 12:4:4:7 5 5
    time 104: 20 13 0 12:4:4:4 7 7
       …中略…
    time 2985: 597 373 1 60:60:52:53 38 38
    time 2990: 598 373 1 61:60:52:53 38 38
    time 2992: 598 374 1 61:60:60:52 39 39
    time 2995: 599 374 1 63:61:60:52 39 39
    Simulation end

TimeKeeper は単なるおまけクラスなので、途中でクロックを止めたり再開し
たり等の複雑な制御はできません。そういう複雑な制御をしたいなら [F.2.4] 
節のように自前でクロック管理すればよし。

--------------------------------------
[F.3] CycleC::Circuit 追加リファレンス
--------------------------------------

[F.3.0] プリプロセッサマクロ CYCLEC_MULTICLOCK
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
多相クロックシミュレーションをする際には、プリプロセッサマクロ
CYCLEC_MULTICLOCK を定義して cyclec.h, cyclec.cc を使う必要があります。
ユーザー回路ソースコードも cycle.cc も、CYCLEC_MULTICLOCK を定義してコ
ンパイル＆リンクする必要があります。多相クロックシステム内のパーツとし
て使う単相クロック回路も、CYCLEC_MULTICLOCK を定義してコンパイルし直す
必要があります。

プログラム全体に渡って CYCLEC_MULTICLOCK を確実に定義するため、
Makefile の CFLAGS で -DCYCLEC_MULTICLOCK を指定するなり、cyclec.h 自
体を改造して冒頭で #define CYCLEC_MULTICLOCK するなりしてください。

CYCLEC_MULTICLOCK を定義した状態の CycleC ライブラリは、定義しない状態
の上位互換になります。したがって、管理が面倒ならば、単相だろうが多相だ
ろうが無条件に CYCLEC_MULTICLOCK を定義する、という使いかたをしてもか
まいません。ただ、単相クロックで事足りるのであれば、CYCLEC_MULTICLOCK 
を定義しないほうが、高速かつ省メモリになります。

[F.3.1] クロック番号集合ビットマップ型 clkmap_t
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
CycleC::Circuit::clkmap_t は、クロック番号集合ビットマップを表す符号無
し整数型の typedef です。とりあえず unsigned int にしてありますが、多
数のクロックを扱いたい場合は unsigned long long int や Bignum クラス等
にカスタマイズしてもいいでしょう。

LSB がクロック番号 0 に対応するものとします。

[F.3.2] クラス変数 the_active_clock_map
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
CycleC::Circuit::the_active_clock_map は、clkmap_t 型の public なクラ
ス変数で、「evaluate() や update() や tick() 時に有効なクロック番号の
集合ビットマップ」を表すものとします。シミュレーションメインルーチンは、
これを適切に設定してから tb.tick() を呼んでください。

# 「初期化時に設定」でなく、「シミュレーション最中に、tb.tick() を呼ぶ
# たびに、その直前に設定」してください。概念的には tick() の引数といえ
# ます。

初期値は 1<<0 で、「クロック番号 0 だけアクティブ」を意味します。多相
クロックシミュレーションではこの初期値は無意味・無価値・無効です。ただ、
「このクラス変数の存在自体を知らない単相クロックシミュレーションプログ
ラム」が改造無しで動くように、こういう初期値にしてあります。

[F.3.3] メンバ変数 m_clockmap
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
m_clockmap は、回路実装者向けの protected 変数です。「その回路インスタ
ンスが従うべきクロック番号」の集合を表すビットマップです。

多相クロックの回路クラスは、assign_clocks() 等のクロック登録手続きを定
義して、親回路から通知されたクロック番号をもとに m_clockmap を適切に設
定してください。

階層回路の m_clockmap は、「自身とサブ回路が使うクロック番号全て」の集
合ビットマップとします。「下位階層の回路が内部的に倍速で動くだけで、上
位階層は倍速クロックのことを意識しない」ような回路アーキテクチャであっ
ても、CycleC としては、「上位階層回路は本クロックと倍速クロックのマル
チクロック回路である」とみなす必要があります。トップ階層 (テストベンチ
クラス) は、システム内で使われるクロックを全て把握し、通し番号をつけ、
各回路に通知するものとします。

# m_clockmap はクラス変数でなくメンバ変数です。同じ種類 (クラス) の回
# 路でも、インスタンスごとに所属クロックドメインが異なる、というケース
# は大いにあり得ますから。

CycleC::Circuit の evaluate(), update() 手続きは、m_clockmap と
the_active_clock_map を照合し、共通ビットがなければ、「無関係なクロッ
クのエッジ」とみなして何もせず (サブ回路再帰処理もせず) リターンします。
このショートカットにより、無関係なクロックエッジのときに階層の末端回路
までスキャンする無駄を省き、シミュレーション速度低下を防ぎます。

また、CycleC::Circuit の update() 手続きは、m_clockmap に 1 個所だけビッ
トが立っている場合だけ (i.e. 回路インスタンスが単相クロックパーツであ
るときだけ)、ポートやレジスタの更新処理を行います。m_clockmap に 2 個
所以上ビットが立つ真の多相クロック回路においては、update_self() が
the_active_clock_map をチェックしながらポートやレジスタの更新処理を行
うものとします。

m_clockmap のデフォルト値は 1<<0 で、「クロックドメイン 0 に所属する単
相クロック回路である」ことを意味します。多相クロックシミュレーションに
とってはこの初期値は無意味・無価値・無効です。ただ、「このメンバ変数の
存在自体を知らない単相クロックシミュレーションプログラム」が改造無しで
動くように、こういう初期値にしてあります。

[F.3.4] メンバ手続き void assign_clock(int clknr)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
assign_clock() は、階層回路実装者向けの public 手続きです。「多相クロッ
クシステム内のパーツとして使われる単相クロック回路」クラスのための、ク
ロック登録手続きです。

内部的には、自身およびサブ回路全ての m_clockmap を 1<<clknr とします。

この手続きは、真の多相クロック回路クラスにとっては無意味・無価値・無効
です。ということは、Liskov Substitution Principle に違反していることに
なります。Liskov Substitution Principle に従うなら、この手続きは、各単
相クロック回路クラスに提供させるか、CycleC::Circuit 直下に 
CycleC::SingleClockCircuit とでもいう派生クラスを作って提供させる、…
のが本筋であり、CycleC::Circuit に提供させるのは行儀悪いです。しかし、
「多相クロックシミュレーションの事情を知らずに作られた単相クロック回路
クラス」を改造無しで多相クロックシステムパーツとして使えるようにしたかっ
たので、行儀悪いのを承知でこういう設計にしました。

この手続きは、例外を投げることはありません。

----------------------------------------
[F.4] ポートとレジスタの追加リファレンス
----------------------------------------

[F.4.1] void tick()
^^^^^^^^^^^^^^^^^^^
tick() は、回路実装者向けの public 手続きです。ポートやレジスタの 
update 処理を行います。ポートの場合はキャッシュをクリアし、レジスタの
場合は値を更新します。

ポートやレジスタには evaluate 処理が存在しないので、update 処理を
tick() という手続きで行うことにしています。

単相クロックシミュレーションや、多相クロックシステム内の単相クロック回
路パーツの場合、ポートやレジスタの update 処理は CycleC::Circuit の 
update() 手続きが自動的に面倒をみてくれるので、利用者がこの手続きを知
る必要はありません。しかし、真の多相クロック回路の場合、「どのクロック
の立ち上がりエッジでどのポート・レジスタを update すればいいのか」を自
動的には判断できないので、CycleC::Circuit の update() 手続きはポート・
レジスタの面倒をみることができません。具体回路クラスの update_self() 
手続きが自力で面倒をみてください。

この手続きは、例外を投げることはありません。

-------------------------------------
[F.5] CycleC::TimeKeeper リファレンス
-------------------------------------

TimeKeeper は、多相クロックのクロック進行管理を支援するユーティリティ
クラスです。

[F.5.1] TimeKeeper()
^^^^^^^^^^^^^^^^^^^^
コンストラクタです。引数はありません。

シミュレーションメインルーチンは、シミュレーション初期化時に
TimeKeeper オブジェクトを生成してください。

この手続きは、std::bad_alloc 等の std::vector 系例外を投げるおそれがあ
ります。

[F.5.2] void define_clock(int id, uint period, uint start_time = 0)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
クロックを 1 つ登録する手続きです。引数は、クロック番号と、クロッ
ク周期と、クロック動作開始時刻です。

シミュレーションメインルーチンは、シミュレーション初期化時に、システム
内のクロックを全てこの手続きを使って登録してください。

クロック番号は順不同や歯抜けでもかまいません。重複していたり clkmap_t 
のビットサイズを越えていてもエラーにはならないので、利用者側で責任を持っ
て正しく指定してください。

クロック周期や動作開始時刻の単位は、利用者側で好きに定義してください。
TimeKeeper クラス自身は時刻の単位には関知しません。

# 時刻の単位は unsigned int 決め打ちです。Keep It Simple, Stupid。

動作開始時刻に 0 を指定すると、本来なら「時刻ゼロでクロックエッジイベ
ントが発生する」と解釈すべきですが、時刻ゼロでクロックエッジイベントを
発生させるのは何かと違和感があるので、動作開始時刻 0 と指定されたとき
のみ、「1 クロック周期後に動作開始」と特殊解釈することにします。

この手続きは、std::bad_alloc 等の std::vector 系例外を投げるおそれがあ
ります。

[F.5.3] void advance()
^^^^^^^^^^^^^^^^^^^^^^
時刻を 1 ステップ (いずれかのクロックの立ち上がりエッジまで) 進める手
続きです。

内部的に、登録済クロックをスキャンして「一番間近なクロック立ち上がりエッ
ジ時刻」を検索し、内部の時刻ワークをその時刻まで進めます。

この手続きは、例外を投げることはありません。

[F.5.4] uint time() const
^^^^^^^^^^^^^^^^^^^^^^^^^
内部の時刻ワークの値を返します。

この手続きは、例外を投げることはありません。

[F.5.5] uint cycle(int clkid) const
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
現在時刻が、指定されたクロック番号にとって何サイクル目なのか、を返します。

この情報は advance() 時にメンテナンスされているので、cycle() 時には
一瞬 (クロックリストを検索する時間のみ) で取り出せます。

この手続きは、clkid が登録済クロック番号でない場合に std::logic_error 
例外を投げます。それ以外の例外を投げることはありません。

[F.5.6] clkmap_t clockmap() const
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
現在の時刻に立ち上がりエッジとなっているクロック番号の集合ビットマップ
を返します。

# clkmap_t は正確には CycleC::Circuit::clkmap_t です。

シミュレーションメインルーチンは、この値を CycleC::Circuit::
the_active_clock_map に設定して tb.tick() を呼んでください。

この値は advance() 時にメンテナンスされているので、clockmap() 時には
一瞬で取り出せます。

この手続きは、例外を投げることはありません。

[F.5.7] void reset()
^^^^^^^^^^^^^^^^^^^^
内部の時刻ワークを 0 にリセットします。

それに伴い、cycle() や clockmap() 用の補助ワークもリセットします。

クロック登録情報はリセットしません。

同じクロック構成のまま時刻ゼロからシミュレーションをやり直したいときに、
この手続きを呼んでください。

--------------
[F.6] 制限事項
--------------

CycleC の多相クロックシミュレーションには、「任意の回路をシミュレーショ
ンできるわけではない」という制約があります。

この制約は、入出力ポートのキャッシュ機能に起因します。入出力ポートの
キャッシュは、そのポートが所属するクロックの立ち上がりエッジでしかクリ
アされないため、何も考えずに多相シミュレーションしようとすると以下のよ
うな不都合が生じます。

  (1) 100MHz(φ1) 回路 A の入力ポート din に、300MHz(φ2) 回路 B の
      出力信号 dout が接続されている。
  (2) ある時刻にφ2 が立ち上がって、B.dout が変化した。
  (3) その時刻にシミュレーションメインルーチンが、信号覗き見表示の
      ために A.din.get() を呼び出した。A.din.get() は B.dout.get()
      を呼び出して B.dout の現在値を取得し、その値をキャッシュした。
  (4) φ1 の立ち上がりまでにはまだまだ時間があり、次のφ2 立ち上がり
      エッジ時刻のほうを先に迎えて、B.dout が変化した。
  (5) しかし、A はφ2 のことを知らないので、A.din は古い入力信号値を
      キャッシュしたままである。
  (6) いよいよφ1 の立ち上がり時刻を迎え、A が evaluate 処理を行った。
      A.evaluate_self() は内部 FF に din を取り込むために din.get()
     を呼び出した。すると din.get() はキャッシュしたままの古い値を
     返した！

このシナリオだけ見るとφ1 とφ2 の周波数が逆転していれば不都合は
生じないように思えるかもしれませんが、そんなことはありません。

  (1) ある時刻にφ1 が立ち上がり、回路 A がその瞬間の din に
      基づいて状態更新を行うと同時に din のキャッシュをクリアした。
  (2) その直後にシミュレーションメインルーチンが信号覗き見表示の
      ために A.din.get() を呼び出した。A.din.get() は B.dout.get()
      を呼び出して B.dout の現在値を取得し、その値をキャッシュした。
  (3) 次にφ2 が立ち上がり、B.dout が変化した。しかし A.din は
      そのことを知らずに古い値をキャッシュしたまま。
  (4) 次にφ1 が立ち上がり、回路 A が evaluate,update 処理を行おうと
      した。A.evaluate_self() が din.get() を呼び出し、din.get() は
      キャッシュしたままの古い値を返した！

[F.2] 節の例ではクロックドメイン境界は m_ff0→m_ff1 という
Register<uchar> 直結コードになっており、上記の問題は生じませんでした。
もし「m_ff0 込みのクロックドメイン 1 回路」「m_ff1,m_ff2 込みのクロッ
クドメイン 2 回路」という構成にしてポート接続していたら、上記の問題が
発生するおそれがありました。

問題を回避するためには、
  ・クロックドメイン境界でポートを使わないようにする
あるいは
  ・シミュレーションメインルーチンがクロックドメイン境界の入力ポートを
    直接的にも間接的にも覗き見しないようにする
という配慮が必要です。

# 「問題を回避するのでなく、ポートにキャッシュ禁止機構を追加することに
# よって問題を解決する」という案もあるのですが、性能ペナルティが気にな
# るのでボツ。

======================
[G] 使用済み名前リスト
======================

CycleC ライブラリでは、実装の都合上、[A]〜[F] 節で説明した以外にもいく
つかの識別子が使われています。それらはライブラリ利用者には見えてほしく
ない識別子なのですが、見えてしまっている以上、利用者は同名識別子を別用
途に使うことができません。申しわけありませんが、利用者は以下の識別子を
避けるよう、お願いします。

以下の表で o 印は [A]〜[F] 節の説明で出てきたもの (利用者に見えてしか
るべき識別子)、x 印は説明されてないもの (利用者に見えてほしくない識別
子) です。

  o HAS_COMBOUTPORT                プリプロセッサマクロ
  o CombOut                        プリプロセッサマクロ
  o RegRefOut                      プリプロセッサマクロ
  o VarRefOut                      プリプロセッサマクロ
  o CYCLEC_MULTICLOCK              プリプロセッサマクロ
  x CYCLEC_INCLUDED                プリプロセッサマクロ

  x CycleC::Object                 Circuit::Circuit のベースクラス
  o CycleC::Object::name           メンバ関数
  x CycleC::Object::parent         メンバ関数
  x CycleC::Object::set_myname     メンバ関数
  x CycleC::Object::set_parent     メンバ関数
  x CycleC::Object::myname         メンバ関数

  x CycleC::ClockedObject          ポートやレジスタのベースクラス
  o CycleC::ClockedObject::tick    メンバ関数
  x CycleC::ClockedObject::reset   メンバ関数

  o CycleC::Port                   ポートのベースクラス
  o CycleC::Port::get              メンバ関数

  x CycleC::OutPort                出力ポートのベースクラス

  o CycleC::Circuit                       回路のベースクラス
  o CycleC::Circuit::Name                 回路インスタンス名のクラス
  o CycleC::Circuit::evaluate             メンバ関数
  o CycleC::Circuit::update               メンバ関数
  o CycleC::Circuit::tick                 メンバ関数
  o CycleC::Circuit::reset                メンバ関数
  o CycleC::Circuit::evaluate_self        メンバ関数
  o CycleC::Circuit::update_self          メンバ関数
  o CycleC::Circuit::reset_self           メンバ関数

  o CycleC::Circuit::Register             レジスタのクラス
  x CycleC::Circuit::Register::NxtProxy   クラス
  x CycleC::Circuit::Register::CkeProxy   クラス
  o CycleC::Circuit::Register::cur        メンバ関数
  o CycleC::Circuit::Register::nxt        メンバ関数
  o CycleC::Circuit::Register::cke        メンバ関数

  o CycleC::Circuit::InPort               入力ポートのクラス
  x CycleC::Circuit::InPort::Proxy        クラス
  o CycleC::Circuit::InPort::connect      メンバ関数
  o CycleC::Circuit::InPort::src          メンバ関数

  x CycleC::Circuit::CombOutPortBase      CombOutPort のベースクラス

  o CycleC::Circuit::FwdOutPort           転送出力ポートのクラス
  x CycleC::Circuit::FwdOutPort::Proxy    クラス
  o CycleC::Circuit::FwdOutPort::connect  メンバ関数
  o CycleC::Circuit::FwdOutPort::src      メンバ関数

  o CycleC::Circuit::RegOutPort           レジスタ出力ポートのクラス
  o CycleC::Circuit::RegOutPort::cur      メンバ関数
  o CycleC::Circuit::RegOutPort::nxt      メンバ関数
  o CycleC::Circuit::RegOutPort::cke      メンバ関数

  o CycleC::Circuit::VarOutPort           変数出力ポートのクラス
  o CycleC::Circuit::VarOutPort::set      メンバ関数

  o CycleC::Circuit::RegRefOutPort        レジスタ参照ポートのクラス
  o CycleC::Circuit::VarRefOutPort        変数参照ポートのクラス

  o CycleC::Circuit::clkmap_t             typedef
  o CycleC::Circuit::the_active_clock_map クラス変数
  o CycleC::Circuit::assign_clock         メンバ関数

  x 具体回路クラス::circuit_type          typedef
  o 具体回路クラス::CombOutPort           組み合わせ論理出力ポート

  o CycleC::TimeKeeper                    多相クロック支援クラス
  o CycleC::TimeKeeper::define_clock      メンバ関数
  o CycleC::TimeKeeper::advance           メンバ関数
  o CycleC::TimeKeeper::time              メンバ関数
  o CycleC::TimeKeeper::cycle             メンバ関数
  o CycleC::TimeKeeper::clockmap          メンバ関数
  o CycleC::TimeKeeper::reset             メンバ関数

